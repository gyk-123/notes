# Tony Bai - Go语言第一课

## 推荐入坑理由

* 对初学者足够友好，能够快速上手
  * 语法简单，可以快速学习语法，编写简单、实用应用
  * 设计者在发布 Go 1.0 版本和兼容性规范后，主要精力还是打磨 Go 实现，改进周边工具链
* 生产力与性能的最佳组合
  * 创建最初目的，就是构建流行的、高性能的服务端编程语言
  * 性能也有明显优势，与不带 GC 的静态编程语言（C/C++）之间也没有数量级的差距
  * 对于动态语言用户友好，并且和动态语言相比，可以在保持生产力的同时，大幅度提高性能
  * 在云原生基础设施、中间件与云服务领域大放异彩
  * 可以应用在 DevOps/SRE、区块链、命令行交互程序（CLI）、Web 服务，数据处理方面
* 快乐且具有前景
  * 相对于 C/C++、Java，Go 在开发体验上有很多提升，包括简单的语法、得心应手的工具链、丰富和健壮的标准库，生产力与性能的完美结合，免除内存管理的心智负担，对并发设计的原生支持等等
  * 可以使用 Go 体现自身价值，有非常广泛的应用场景

## GO 历史与现状

### Go 语言是怎样诞生的

Go 语言的创始人有三位，分别是图灵奖获得者、C 语言联合发明人、Unix 之父肯·汤普森（Ken Thompson ），Plan 9 操作系统领导者、UTF - 8 编码的最初设计者罗伯·派克（Rob Pike），以及 Java 的 HotSpot 虚拟机和 Chrome 浏览器的 JavaScript V8 引擎的设计者之一罗伯特·格瑞史莫（Robert Griesemer）。

他们三个人在 2007 年 9 月 20 日下午的一次普通讨论，成了计算机编程语言领域的一次著名历史事件，开启了一个新编程语言的历史。

在谷歌山景城总部的办公室里，罗伯 · 派克启动了一个 C++ 工程的构建，根据以往的经验，这次构建大约需要一个小时。利用这段时间，罗伯·派克和罗伯特·格瑞史莫、肯·汤普森坐在一起，交换了关于设计一门新编程语言的想法。

之所以产生这种想法，是因为当时谷歌内部主要适用 C++ 语言构建各种系统，但 C++ 的巨大复杂性，编译构建速度慢以及在编写服务端程序时对并发支持的不足，让三位大佬觉得非常不便，于是他们就想着设计一门新的语言。在他们的初步构想中，这门新语言应该是能够给程序员带来快乐、匹配未来硬件发展趋势并适合用来开发谷歌大规模网络服务程序的。

在一天的简短讨论后，第二天三位大佬具体讨论了这门新语言的设计。会后罗伯特·格瑞史发出电邮，对这门新编程语言的功能特性做了初步归纳总结。主要思路是，在 C 语言的基础上，修正一些明显的缺陷，删除一些被诟病较多的特性，增加一些缺失的功能。例如，使用 import 替代 include、去掉宏、增加垃圾回收、支持接口等。这封电邮成为这门新语言的第一版特性设计稿，三位大佬在这门语言的一些基础语法特性上达成初步一致。

9 月 25 日，罗伯·派克在一封回复电邮中把这门新编程语言命名为 “go”。在罗伯 · 派克的心目中，“go” 这个单词短小、容易输入并且在组合其他字母后便可以用来命名 Go 相关的工具，比如编译器（goc）、汇编器（goa）、链接器（gol）等。

> go 早期版本曾如此命名 go 工具链，但后续版本撤销了这种命名方式，仅保留 go 这一统一的工具链名称。

另外，很多 Go 语言初学者经常称这门语言为 Golang，其实这是不对的：“Golang” 仅应用于命名 Go 语言官网网站，没有使用 go.com 纯粹是因为这个域名被占用了而已。

### “三人行” 到 ”众人拾柴“

经过早期讨论，Go 语言的三位作者在语言设计达成初步一致后，便开启了 Go 语言迭代设计和实现的过程。

2008 年初，Unix 之父肯·汤普森实现了第一版 Go 编译器，用于验证之前的设计。这个编译器先将 Go 代码转换为 C 代码，再由 C 编译器编译成二进制文件。

2008 年年中，Go 的第一版设计就基本结束了。这是，同样在谷歌工作的伊恩·泰勒（Ian Lance Taylor）为 Go 语言实现了一个 gcc 的前端，这也是 Go 语言的第二个编译器。伊恩·泰勒的成本不仅仅是一种鼓励，也证明了 Go 这一新语言的可行性。随后，伊恩·泰勒以团队第四位成员的身份正式加入 Go 语言开发团队，后面也成了 Go 语言，以及其工具设计和实现的核心人物之一。

> 一个编译器的完整编译过程包括：词法分析、语法分析、类型检查、中间代码生成、代码优化、目标代码生成、目标代码优化等几个阶段。从词法分析到中间代码生成，这就是编译器前端所要负责的事情。代码优化和目标代码生成，则是编译器后端的职责。
>
> 上面所说的实现 gcc 的前端，就是实现一个程序，这个程序可以读取 go 源码并通过词法分析、语法分析、类型检查，最终生成中间代码，而这个中间代码可以被 gcc 后端所识别并生成最终目标代码。

罗斯·考克斯（Russ Cox）是 Go 核心开发团队的第五位成员，也是在 2008 年加入。随后，罗斯·考克斯利用函数是 “一等公民”，并且它也可以拥有自己的方法这一特性设计出了 http 包的 HandlerFunc 类型。这样，我们通过显式转型就可以让一个普通函数称为满足 http.Handler 接口的类型。

> 在 Go 中，如果一个变量的类型为 int，如果我们要将其与另一个 int 64 类型的变量进行加法运算，我们不能直接将它们相加，我们必须将它们显示的转换为同一类型后才能想家，这里的转换过程就简称为显式转型。

不仅如此，罗斯·考克斯还在当时设计的基础上提出一些更泛化的想法，比如 io.Reader 和 io.Writer 接口，这就奠定了 Go 语言的 I/O 结构模型。后来，罗斯·考克斯成为 Go 核心技术团队的负责人，推动 Go 语言的持续演化。

至此，Go 语言最初的核心团队形成，Go 语言迈上稳定演化的道路。

2009 年 10 月 30 日，罗伯·派克在 Google Techtalk 上做了一次有关 Go 语言的演讲，“The Go Programming Language”，这是 Go 语言第一次公之于众。十天后，2009 年 11 月 10 日，谷歌官方宣布 Go 语言项目开源，之后这一天也被 Go 官方确定为 Go 语言的诞生日。

在 Go 语言项目开源后，Go 语言也迎来了自己的 “吉祥物”，是一只由罗伯·派克夫人芮妮·弗伦奇（Renee French）设计的地鼠，从此地鼠（gopher）也就成为了世界各地 Go 程序员的象征，Go 程序员也被昵称为 Gopher。

<img src="./images/go.png" />

Go 语言项目的开源吸引了全世界开发者的目光，再加上 Go 三位作者在业界的影响力以及谷歌这座大树的加持，更多有才华的程序员加入到 Go 核心开发团队中，更多贡献者开始为 Go 语言项目添砖加瓦。于是，Go 在宣布开源的当年，就成为了著名编程排行榜 TIOBE 的年度编程语言。

2012 年 3 月 28 日，Go 1.0 版本正式发布，同时 Go 官方发布了 “Go 1 兼容性” 承诺：只要符合 Go 1 语言规范的源代码，Go 编译器将保证向后兼容（backwards compatible），也就是说我们使用新版编译器也可以正确编译用老版本语法编写的代码。

从正式开源到现在，Go 语言发布了多个大版本更新，逐渐成熟。下面梳理了迄今为止 Go 语言的重大版本更新，希望可以帮助你快速了解 Go 语言的演化历史。

<img src="./images/go_history.png" />

经过十余年的打磨与优化，如何的 Go 语言已经逐渐成为云计算时代基础设施的编程语言。你能想到的现代云计算基础设施软件的大部分流行和可靠的作品，都是用 Go 编写的，比如：Docker、Kubernetes、Prometheus、Ethereum（以太坊）、lstio、CockroachDB、InfluxDB、Terraform、Etcd、Consul 等等，可以看 Go 语言的影响力已经十分强大。

### 总结

一门编程语言的历史和现状，可以给你带来学习的 “安全感”，相信它可以提升你的个人价值，也会让你获得丰富的回报。你也会更加清楚地认识到：自己为什么要学习它？它未来的发展趋势又是怎样的？当这门语言的现状能给予你极大 “安全感” 的时候，我们才会 “死心塌地” 地学习和钻研这门技术，不会有太多的后顾之忧。

从 Go 本身的发展来看，和多数编程语言一样，Go 语言在诞生后，度过了一个较长 “技术萌芽期”。然后，实现了自举，发布对 GC 延迟进行大幅优化的 Go 1.5 版本，成为 Go 语言演化过程中的第一个 “引爆点”，推动 Go 语言进入 “技术膨胀期”。

也正是在这段时间内，Go 语言推出了以 Docker、Kubernetes 为典型代表的 “杀手级应用”，充分展示了实力，在世界范围收获了百万粉丝，迸发出极高的潜力和持续的活力。

## Go 语言的设计哲学

很多编程语言的初学者在学习初期，可能都会遇到这样的问题：最初兴致勃勃地开始学习一门编程语言，学着学着就发现很多 “别扭” 的地方，比如想要的语言特性缺失、语法风格偏避与主流语言差异大、语言的不同版本之间无法兼容、语言的语法特性过多导致学习曲线陡峭、语言的工具链支持较差，等等。

以上的这些问题，本质上都与语言设计者的设计哲学有关。所谓编程语言的设计哲学，就是指决定这门语言演化进程的高级原则和依据。

设计哲学之余编程语言，就好比一个人的价值观之余这个人的行为。如果不认同这个人的价值观，那你就很难与之持续交往下去。同理，如果你不认同一门编程语言的设计哲学，那么大概率你会在后续的语言学习中，就会遇到上面提到的问题，而且可能会让你失去继续学习的精神动力。

因此，在正式学习 Go 语法和编码之前，我们还需要先来了解一下 Go 语言的设计哲学。

### 设计哲学

Go 语言的设计哲学可以总结为五点：简单、显式、组合、并发和面向工程。

#### 简单

Go 语言的设计者们在语言设计之初，就拒绝走语言特性融合的道路，选择 “做减法” 并致力于打造一门简单的编程语言。

这也就意味着 Go 不会像 C++、Java 那样将其他编程语言的新特性兼蓄并收，所以你在 Go 语言中看不到传统的面向对象的类、构造函数与继承，看不到结构化的异常处理，也看不到本属于函数编程范式的语法元素。

不过，Go 语也没它看起来那么简单，自身实现起来也并不容易，但这些复杂性都被 Go 语言的设计者们 “隐藏” 了，所以 Go 语法层面上呈现这样的状态：

* 仅有 25 个关键字，主流编程语言很少；
* 内置垃圾收集，降低开发人员内存管理的心智负担；
* 首字母大小写决定可见性，无需通过额外关键字修饰；
* 变量初始为类型零值，避免以随机值作为初值的问题；
* 内置数组边界检查，极大减少越界访问带来的安全隐患；
* 内置并发支持，简化并发程序设计；
* 内置接口类型，为组合的设计哲学奠定基础；
* 原生提供完善的工具链，开箱即用；
* ... ...

我们可以看到 Go 设计者选择的 “简单”，其实是站在巨人肩膀上，去除或优化了以往语言中，已经被开发者证明为体验不好或难以驾驭的语法元素和语言机制，并提出自己的一些创新性的设计。比如，首字母大小写决定可见性、变量初始为类型零值、内置以 go 关键字实现的并发支持等。

简单意味着可以使用更少的代码实现相同的功能，简单意味着代码具有更好的可读性，可读性好的代码通常意味着更好的可维护性以及可靠性。

简单的设计哲学是 Go 生产力的源泉。

#### 显式

首先，我们先来看一段 C 程序，看下 “隐式” 代码的行为特性。

在 C 语言中，下面这段代码可以正常编译并输出正确结果：

```c
#include <stdio.h>

int main() {
    short int a = 5;

    int b = 8;
    long c = 0;
    
    c = a + b;
    printf("%ld\n", c);
}
```

在上面这段代码中，变量 a、b 和 c 的类型均不相同，C 语言编译器在编译 c = a + b 这一行时，会自动将短整型变量 a 和整型变量 b，先转换成 long 类型然后相加，并将所有结果存储在 long 类型变量 c 中。

```go
package main

import "fmt"

func main() {
    var a int16 = 5
    var b int = 8
    var c int64

    c = a + b
    fmt.Printf("%d\n", c)
}
```

我们将上面的 C 程序转换为等价的 Go 代码，当编译程序时，会得到这样的编译器错误：“invalid operation：a + b（mismatched types int16 and in）”。我们能看到 Go 与 C 语言的隐式自动类型转换不同，Go 不允许不同类型的整型变量进行混合计算，它同样也不会对其进行隐式的自动转换。

因此，如果要使这段代码通过编译，我们就需要对变量 a 和 b 进行显式转型，就像下面这段代码：

```go
c = int64(a) + int64(b)
fmt.Printf("%d\n", c)
```

这其实就是 Go 语言显式设计哲学的体现。

在 Go 语言中，不同类型变量是不能在一起进行混合计算的，这是因为 Go 希望开发人员明确知道自己在做什么，你需要以显式的方式通过转型统一参与计算各个变量的类型。

初次之外，Go 设计者所崇尚的显式哲学还直接决定了 Go 语言错误处理的形态：Go 语言采用显式的基于值的错误处理方案，函数/方法中的错误都会通过 return 语句显式地返回，并且通常调用者不能忽略对返回的错误进行处理。

#### 组合

这个设计哲学和我们的各个程序之间的耦合有关，Go 语言不像 C++、Java 等主流面向对象语言，我们在 Go 中见不到经典的面向对象语法元素、类型体系和继承机制，Go 崇尚的是组合的设计哲学。

在 Go 语言设计层面，Go 设计者为开发者们提供正交的语法元素，以供后续组合使用，包括：

* Go 语言无类型层次体系，各类型之间是相互独立的，没有子类型的概念；
* 每个类型都可以有自己的方法集合，类型定义与方法实现是正交独立的；
* 实现某个接口时，无需像 Java 那样采用特定关键字修饰；
* 包之间是相互独立的，没有子包的概念。

> 正交指相互独立，不可替代，并且组合起来可实现其它功能。

无论是包、接口还是具体类型定义，GO 语言其实为我们呈现这样的一幅图景：一座座没有关联的 “孤岛”，但每个岛内又很精彩。Go 采用组合的方式在这些孤岛之间建立关联，形成一个整体。

Go 语言为支撑组合的设计提供了类型嵌入（Type Embedding）。通过类型嵌入，我们可以将已实现的功能嵌入到新类型中，以快速满足新类型的功能需求，这种方式有点类似面向对象语言中的 “继承” 机制，但在原理上完全不同，这是一种 Go 设计者们精心设计的 “语法糖”。

被嵌入的类型和新类型两者之间没有任何关系，甚至相互完全不知道对方的存在，没有面向对象语言中的那种父类、子类的关系，以及向上、向下转型（Type Casting）。通过新类型实例调用方法时，方法的匹配主要取决于方法名字，而不是类型。这种组合方式，可以称之为垂直组合，即通过类型嵌入，快速让一个新类型 “复用” 其他类型已经实现的能力，实现功能的垂直扩展。

下面是 Go 标准库中的一段使用类型嵌入组合方式的代码段：

```go
// $GOROOT/src/sync/pool.go
type poolLocal struct {
    private interface{}   
    shared  []interface{}
    Mutex               
    pad     [128]byte  
}
```

在代码段中，我们在 poolLocal 这个结构体类型中嵌入类型 Mutex，这使得 poolLocal 这个类型具有互斥同步的能力，我们可以通过 poolLocal 类型的变量，直接调用 Mutex 类型的方法 Lock 或 Unlock。

另外，我们在标准库中还会看到类似如下定义接口类型的代码段：

```go
// $GOROOT/src/io/io.go
type ReadWriter interface {
    Reader
    Writer
}
```

这里，标准库通过嵌入接口类型的方式来实现接口行为的聚合，组成大接口，这种方式在标准库中尤为常用，并且已经成为 Go 语言的一种惯用法。

垂直组合本质上是一种 “能力继承”，采用嵌入方式定义的新类型继承嵌入类型的能力。Go 还有一种常见的组合方式，叫水平组合。和垂直组合的能力继承不同，水平组合是一种能力委托（Delegate），我们通常使用接口类型来实现水平组合。

Go 语言中的接口是一个创建设计，它知识方法集合，并且它与实现者之间的关系无需通过显式关键字修饰，它让程序内部各部分之间的耦合降至最低，同时它也是连接程序各个部分之间的 “纽带”。

水平组合的模式有很多，比如一种常见方法就是，通过接受接口类型参数的普通函数进行组合，如以下代码所示：

```go
// $GOROOT/src/io/ioutil/ioutil.go
func ReadAll(r io.Reader)([]byte, error)

// $GOROOT/src/io/io.go
func Copy(dst Writer, src Reader)(written int64, err error)
```

函数 ReadAll 通过 io.Reader 这个接口，将 io.Reader 的实现与 ReadAll 所在的包低耦合地水平组合在一起，从而达到从任意实现 io.Reader 的数据源读取所有数据的目的。类似的水平组合 “模式” 还有点缀器、中间件等。

此外，我们还可以将 Go 语言内置的并发能力进行灵活组合以实现，比如，通过 goroutine + channel 的组合，可以实现类似 Unix Pipe 的能力。

总之，组合原则的应用实质上是塑造 Go 程序的骨架结构。类型嵌入为类型提供了垂直扩展能力，而接口是水平组合的关键，它好比程序肌体上的 “关节”，给予连接 “关节” 的两个部分各自 “自由活动” 的能力，而整体上又实现某种功能。并且，组合也让遵循 “简单” 原则的 Go 语言，在表现力上丝毫不逊色于其他复杂的主流编程语言。

#### 并发

“并发” 这个设计哲学的出现也有有它的背景，CPU 都是靠提高主频来改进性能的，但是这个做法已经遇到瓶颈。主频提高导致 CPU 的功耗和发热量剧增，反过来制约 CPU 性能的进一步提高。2007 年开始，处理器厂商的竞争焦点从主频转向了多核。

在这种大背景下，Go 的设计者在决定创建一门新语言的时候，果断将面向多核、原生支持并发作为新语言的设计原则之一。并且，Go 放弃了传统的基于操作系统线程的并发模型，采用用户层轻量级线程，Go 将之称之为 goroutine。

goroutine 占用的资源非常小，Go 运行时默认为每个 goroutine 分配的占空间仅 2 KB。goroutine 调度的切换也不用陷入（trap）操作系统内核层完成，代价很低。因此，一个 Go 程序中可以创建成千上万个并发的 goroutine。而且，所有的 Go 代码都在 goroutine 中执行，哪怕是 go 运行时的代码也不例外。

在提供了开销较低的 goroutine 的同时，Go 还在语言层面上内置了辅助并发设计的原语：channel 和 select。开发者可以通过语言内置的 channel 传递消息或实现同步，并通过 select 实现多路 channel 的并发控制。相较于传统复杂的线程并发模型，Go 与并发的原生支持将大大降低开发人员在开发并发程序时的心智负担。

此外，并发的设计哲学不仅仅让 Go 在语法层面提供了并发原语支持，对 Go 应用程序设计的影响更为重要。并发是一种程序结构设计的方法，使得并行成为可能。

采用并发方案设计的程序在单核处理器也是可以正常运行的，也许在单核上的处理性能可能不如非并发方案。但随着处理器核数的增多，并发方案可以自然地提高处理性能。

而且，并发与组合的哲学是一脉相承的，并发是一个更大的组合概念，它在程序设计的全局层面对程序进行拆解组合，再映射到程序执行层面上：goroutines 各自执行特定的工作，通过 channel + select 将 goroutines 组合连接起来。并发的存在鼓励程序员在程序设计时进行独立计算的分解，而对并发的原生支持让 Go 语言更适合现代计算环境。

#### 面向工程

Go 语言设计的初衷，就是面向解决真实世界中 Google 内部大规模软件开发中存在的各种问题，为这些问题提供答案，例如：程序构建慢、依赖管理失控、代码难于理解、跨语言构建难等。

Go语言最初设计阶段就将解决工程问题作为 Go 的设计原则之一，去考虑 Go 语法、工具链与标准库的设计，这也是 Go 与其他偏学院派、偏研究型的编程语言在设计思路上的一个重要差异。

语法是编程语言的用户接口，它直接影响开发人员对这门语言的使用体验。在面向工程设计哲学的驱使下，Go 在语法设计细节上做了精心打磨。

* 重新设计编译单元和目标文件格式，实现 Go 源码快速构建，使大工程的构建时间缩短到类似动态语言的交互式解释的编译速度；
* 如果源文件导入它不使用的包，程序将无法编译。这可以充分保证任何 Go 程序的依赖树是精确的，也可以保证构建程序时不会编译额外的代码，从而最大限度地缩短编译时间；
* 去除包的循环依赖，循环依赖会在大规模的代码中引发问题，因为它们要求编译器同时处理更大的源文件集，这会减慢增量构建；
* 包路径是唯一的，包名不必唯一。导入路径必须唯一标识要导入的包，名称只是包的使用者如何引用其内容的约定。“包名称不必是唯一的” 这个约定，可以大大降低开发人员给包起唯一名字的心智负担；
* 不支持默认函数参数。因为在规模工程中，很多开发者利用默认函数参数机制，向函数添加过多的参数以弥补函数 API 的设计缺陷，这会导致函数拥有太多的参数，降低清晰度和可读性；
* 增加类型别名（type alias），支持大规模代码库重构。

在标准库方面，Go 语言标准库功能丰富，多数功能不需要依赖外部的第三方包或库。Go 在标准库中提供了各种高质量且性能优良的功能包，其中 net/http、crypto、encoding 等包充分迎合了云原生时代的关于 API/RPC Web 服务器的构建需求，Go 开发者可以直接基于标准库提供的包实现一个满足生产要求的 API 服务，从而减少对外部第三方包或库的依赖，降低工程代码依赖管理的复杂性，降低开发人员学习第三方库的心理负担。

除此之外，Go 语言还提供了完善的工具链支持，涵盖了编译构建、代码格式化、包依赖管理、静态代码检查、测试、文档生成与查看、性能剖析、语言服务器、运行时程序跟踪等方方面面。

值得重点介绍的是 gofmt，它可以统一 Go 语言的代码风格，使开发者可以更加专注于业务。同时，相同的代码风格可以让开发者的代码阅读、理解和评审工作变得更加容易。Go 的这种统一代码风格思路也开始影响后续新编程语言的设计，并且一些现有的主流编程语言也在借鉴 Go 的一些设计。

在提供丰富工具链的同时，Go 在标准库中还提供了官方的词法分析器、语法解析器和类型检查器相关包，开发者可以基于这些包快速构建并扩展 Go 工具链。

### 总结

这篇文章我们了解了 Go 语言的设计哲学：简单、显式、组合、并发和面向工程。

* 简单是指 Go 语言特性始终保持在少且足够的水平，不走语言特性融合的道路，但又不缺乏生产力。简单是 Go 生产力的源泉，也是 Go 对开发者的最大吸引力；
* 显式是指任何代码行为都需要开发者明确知晓，不存在因隐式转型导致可维护性降低和不安全的结果；
* 组合是构建 Go 程序骨架的主要方式，它可以大幅度降低程序元素间的耦合，提高程序的可扩展性和灵活性；
* 并发是 Go 把握 CPU 向多核方向发展趋势的产物，可以让那个开发人员更容易写出充分利用系统资源、支持性能随 CPU 核数增加而自然提升的应用程序；
* 面向过程是 Go 语言在语言设计上的一个重大创新，它将语言要解决的问题域扩展到那些原本并不是由编程语言去解决的领域，从而覆盖更多开发者在开发过程中的 “痛点”，为开发者提供更好的使用体验。

### 技术拓展

**关于 “类型别名” 的渐进式代码修复（Gradual code repair）**

https://github.com/golang/proposal/blob/master/design/18130-type-alias.md

它也是 Go 面向工程设计哲学的体现，另外 type alias 对基于现有实现进行扩展并做出新的封装方面也有 “奇效”。

## 环境配置

这一篇文章主要介绍如何安装和配置 Go 语言开发环境。

### 选择 Go 版本

挑选版本之前，我们先来看看 Go 语言的版本发布策略。

Go 团队目前已经将版本发布节奏稳定在每年发布两次大版本，通常是二月份和八月份。Go 团队承诺对最新的两个 Go 稳定大版本提供支持，比如目前的最新的大版本是 Go 1.19，那么 Go 团队就会为 Go 1.19 和 Go 1.18 版本提供支持。如果 Go 1.20 版本发布，那支持的版本将编程 Go 1.20 和 Go 1.19。支持的范围主要包括修复版本中存在的重要问题、文档变更以及安全问题更新等。

基于这样的版本发布策略，我们在选择版本时可以参考这几种思路：

一般情况下，建议使用最新版本。因为 Go 团队发布的 Go 语言稳定版本的平均质量一直是很高的，很少有影响使用的重大 bug。我们也不必担心新版本的支持问题，Google 的自有产品，比如 Google App Engine 支持都会很快，一般在 Go 新版本发布不久后，GAE 便会支持最新版本的 Go。

你还可以根据不同实际项目需要或开源社区的情况使用不同版本。

有的开源项目采纳 Go 团队建议，在 Go 最新版本发布不久就将当前项目的 Go 编译器升级到最新版，例如 kubernets 项目；有的开源项目，例如 docker 则比较谨慎，这些项目可能会使用两个发布周期之前的版本。多数项目处于两者之间，也就是使用次新版，即最新版本之前的那个版本。

因为我们是 Go 语言学习，所以推荐直接使用 Go 最新发布版。这样我们可以体验到 Go 的最新语言特性，应用到标准库的最新 API 以及 Go 工具链的最新功能。

选定 Go 版本后，接下来我们就来看看几种常见的 Go 安装方法。

### 安装 Go

在 Mac 上我们可以在图形界面的引导下进行 Go 的[安装](https://go.dev/dl/)。

首先我们需要下载适用于 Mac 的 Go 安装包（这里以 arm 为例）：

```
wget -c https://go.dev/dl/go1.19.4.darwin-arm64.pkg
```

安装包下载完毕后，双击安装包，就可以打开标准的 Mac 软件安装界面，如下图所示：

<img src="./images/install.png" />

按照软件安装向导提示，一路点击 “继续”，我们便可以完成 Go 在 Mac 上的安装。

Mac 上的 Go 安装包默认也会将 Go 安装到 /usr/local/go 路径下面。因此，如果要在任意路径下使用 Go，我们也需将这个路径加入到用户的环境变量 PATH  中。

```
export PATH=$PATH:/usr/local/go/bin
```

最后，我们同样可以通过 go version 命令验证这次安装是否成功。除此之外，我们还可以使用 brew 安装 Go。

### 配置 Go

Go 在安装后是开箱即用的，这也意味着我们在使用 Go 之前无需做任何配置。但为了更好地了解和学习 Go，我们还是要认识一些 Go 自带的常用配置项。Go 的配置项是以环境变量的形式存在的，我们可以通过下面这个命令查看 Go 的这些配置项：

```
go env
```

下面总结了一些常用配置项：

| 名称        | 作用                                                         | 值                                                           |
| ----------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| GOARCH      | 用于指示 Go 编译器生成代码所针对的平台 CPU 架构              | 主要值是 AMD64、Arm 等，默认值是本机的 CPU 架构              |
| GOOS        | 用于指示 Go 编译器生成代码所针对的操作系统                   | 主要值是 Linux、Darwin、Windows 等，默认值是本机的操作系统   |
| GO111MODULE | 它的值决定当前使用的构建模式是传统的 GOPATH 模式还是新引入的 GO Module 模式 | 在 Go 1.16 版本 Go Module 构建模式默认开启，该变量值默认为 on，测试 Go 1.19 版本默认为 “” |
| GOCACHE     | 用于指示存储构建结果缓存的路径，这些缓存可能会被后续的构建所使用 | 在不同的操作系统中，GOCACHE 有不同的默认值。以 Mac 为例，我们使用 go env GOCACHE 查看其值为：$HOME/Library/Caches/go-build |
| GOMODCACHE  | 用于指示存放 Go Module 的路径                                | 在不同的操作系统上，GOMODCACHE 有不同的默认值。以 Mac 为例，我们使用 go env GOOMODCACHE 查看其值为：$HOME/go/pkg/mod |
| GOPROXY     | 用来配置 Go Module proxy 服务                                | 默认值为 “https://proxy.golang.org,direct”。中国大陆地区，可以设置为大陆地区提供的 module proxy 服务以加速 Go Module 的获取速度，值为 “https://goproxy.cn,direct”。 |
| GOPATH      | 在传统的 GOPATH 构建模式下，用于指示 Go 包搜索路径的环境变量，在 Go module 机制启用之前是 Go 核心配置项。Go 1.8 版本之前需要手动配置，Go 1.8 版本引入了默认的 GOPATH（$HOME/go）。在 Go Module 模式正式上位后，很可能会被移除。 |                                                              |
| GOROOT      | 指示 Go 安装路径。Go 1.10 版本引入默认 GOROOT，开发者无需显式设置，Go 程序会自动根据自己所在路径推导出 GOROOT 的路径。 |                                                              |

如果你还想了解更多关于 Go 配置项的说明，可以通过 go help environment 命令查看。

### 总结

在这篇文章中，我们讲解三种 Go 版本的选择策略：

* 第一种，也是比较推荐的一种，那就是使用 Go 最新版本，这样就可以体验到 Go 的最新语言特性，应用到标准库的最新 API 以及 Go 工具链的最新功能，并且很多老版本中的 bug 在最新版本中都会得到及时修复；
* 如果你对最新版本的稳定性存在顾虑，你也可以选择使用此新版；
* 最后，如果你要考虑现存生产项目或开源项目，只需要于选择项目保持一致就可以。

确认完 Go 版本后，我们介绍了如果安装 Go。最后，我们讲解了 Go 的一些常用配置项。

有了 Go 开发环境，接下来我们就开始学习如何编写 Go 代码。

## Go 程序的结构

正式开始之前，首先说明一下，这节课对于开发 Go 程序所使用的编辑器工具没有任何要求。

如果你喜欢使用某个集成开发环境（Integrated Development Environment，IDE），那么就用你喜欢的 IDE 就好。

在这里只推荐两款好用的 IDE，GoLand 或 Visual Studio Code（简称 VS Code）。GoLand 是知名 IDE 出品公司 JetBrains 准对 Go 语言推出的 IDE 产品，也是目前市面上最好用的 Go IDE；VS Code 则是微软开源的跨语言源码编辑器，通过集成语言插件（Go 开发者可以使用 Go 官网维护的 vscode-go 插件），可以让它变成类 IDE 的工具。

如果你有黑客情怀，喜欢优雅高效地使用命令行，那么像 Vim、Emacs 这样的基于终端的编辑器同样可以用于编写 Go 源码。以 Vim 为例，结合 vim-go、coc.nvim（代码补全）以及 Go 官方维护的 gopls 语言服务器，在编写 Go 代码时也可以体会到 “飞一般” 的感觉。

### “hello world”

新建一个 helloworld 文件夹。

```
mkdir helloworld
cd helloworld
```

首先，我们需要创建一个名为 main.go 的源文件。

这里说下 Go 的命名规则。Go 源文件总是以全小写字母形式的短小单词命名，并且以 .go 扩展名结尾。

现在，我们打开刚才创建的 main.go 文件，编写下面这段代码：

```go
package main

import "fmt"

func main() {
	fmt.Println("hello, world")
}
```

编写完成后，我们就可以通过以下命令编译和运行这个文件。

```
go build main.go
./main
```

到这里你应该可以看到终端输出 “hello, world” 字符串。

现在，让我们来分析下这段代码。首先值得注意的部分是这个：

```go
package main
```

这一行代码定义了 Go 中的一个包 package。包是 Go 语言的基本组成单元，通常使用单个的小写单词命名，一个 Go 程序本质上就是一组包的集合。所有 Go 代码都有自己隶属的包，这里我们的 “hello, world” 示例的所有代码都在一个名为 main 的包中。main 包在 Go 中是一个特殊的包，整个 Go 程序中仅允许存储一个名为 main 的包。

main 包中的主要代码是一个名为 main 的函数：

```go
func main() {
	fmt.Println("hello, world")
}
```

这里的 main 函数也比较特殊：当你运行一个可执行的 Go 程序的时候，所有的带啊吗都会从这个入口函数开始运行。这段代码的第一行声明了一个名为 main 的、没有任何参数和返回值的函数。如果你想给函数声明参数，必须放到括号中。

另外，花括号 {} 用来标记函数体，Go 要求所有的函数体都要被花括号包裹起来。我们推荐把左花括号与函数声明置于同一行并以空格分割。Go 语言内置了一套 Go 社区约定俗成的代码风格，并随安装包提供了一个名为 Gofmt 的工具，这个工具可以帮助你将代码自动格式化为约定的风格。

Gofmt 是 Go 语言在解决规模化（scale）问题上的一个最佳实践，并成了 Go 语言吸引其他语法开发者的一大卖点。很多其他主流语言也在效仿 Go 语言推出自己的 format 工具，例如：Java formatter、Clang formatter、Dartfmt 等。因此，作为 Go 开发人员，在提交你的代码前要使用 Gpfmt 格式化你的 Go 源码。

我们再来看一看 main 函数体中的代码：

```go
fmt.Println("hello, world")
```

这一行代码已经完成整个示例程序的所有工作：将字符串输出到终端的标准输出（stdout）上。这里有几个细节需要注意：

**标准 Go 代码风格使用 Tab 而不是空格使用缩进，代码风格格式化工作也可以交由 gofmt 完成。**

**我们调用一个名为 Println 的函数，这个函数位于 Go 标准库的 fmt 包中。输出 “hello, world” 做了两部操作。**

第一步是在源文件的开始处通过 import 声明导入 fmt 包的包路径。

```go
import "fmt"
```

第二步则是在 main 函数体内，通过 fmt 这个操作符（Qualified Identifier）调用 PrintIn 函数。虽然两处都使用了 “fmt” 这个字面值，但在这两处 “fmt” 字面值所代表的含义是一样的。

* import “fmt” 一行中的 “fmt” 代表的是包的导入路径（Import），它代表的是标准库下的 fmt 目录，整个 import 声明语句的含义就是导入标准库 fmt 目录下的包；
* fmt.PrintIn 函数调用一行中给的 “fmt” 代表的则是包名。

通常导入路径的最后一个分段名与包名是相同的，这也很容易让人误解 import 声明语句中的 “fmt” 指的是包名。

main 函数体中之所以可以调用 fmt 包中的 PrintIn 函数，还有最后一个原因，那就是 PrintIn 函数的首字母是大写的。在 Go 语言中，只有首字母为大写的标识符才是导出的（Exported），才能对包外的代码可见；如果首字母是小写的，那么就说明这个标识符仅限于在声明它的包内可见。

另外，在 Go 语言中，main 包是不可以像标准库 fmt 包那样导入的，如果导入 main 包，在代码编译阶段就会收到 Go 编译器错误：import "xx/main" is a program, not an importable package。

最后，在整个示例程序源码中，我们都没有使用分号来表示语句结束。不过，其实 Go 语言的正式语法规范是使用分号 “;” 来做结尾标识符的。因为大多数分号都是可选的，常常被省略，不过在源码编译时，Go 编译器会自动插入这些被省略的分号。

### 程序如何编译

刚刚我们在运行 “hello world” 程序之前，使用了 go build 命令，还有它附带的源文件名参数来编译它：

```
go build main.go
```

假设你有 C/C++ 语言的开发背景，你就会发现这个步骤与 gcc 或 clang 编译十分相似。一旦编译成功，我们就会获得一个二进制的可执行文件。在 Linux 系统、MacOS 系统，以及 Windows 系统的 PowerShell 中，我们可以通过输入下面这个 ls 命令看到刚刚生成的可执行文件。

如果之前你更熟悉类似于 Ruby、Python 或 JavaScript 之类的动态语言，你可能还不太习惯在运行之前需要先进行编译的情况。Go 是一种编译型语言，这意味着只有编译完 Go 程序之后，才可以将生成的可执行文件交付给其他人，并可以运行在没有安装 Go 的环境中。

而如果你交付给其他人的是一份 .rb、.py 或 .js 的动态语言的源文件，那么目标环境中就必须要拥有对应的 Ruby、Python 或 JavaScript 环境才能解释执行这些源文件。

当然，Go 也借鉴了动态语言一些对开发者体验比较好的特性，比如基于源码文件的直接执行，Go 提供了 run 命令可以直接运行 Go 源码文件，比如我们也可以使用下面命令直接基于 main.go 运行。

```
go run main.go
```

不过像 go run 这类命令更多应用于开发调试阶段，实际交付成功还是需要使用 go build 命令进行构建。

在我们的生产环境里，Go 程序的编译往往不会像我们前面，基于单个 Go 源文件构建这么简单。越贴近真实环境，也就意味着项目规模越大、协同人员越多，项目的依赖和依赖的版本都会变得复杂。

### 复杂项目编译

现在我们创建一个新项目 “hellomodule”，在新项目中我们使用两个第三方库，zap 和 fasthttp。

```
mddir hellomodule
cd hellomodule
```

接下来编写源码文件：

```go
package main

import (
	"github.com/valyala/fasthttp"
	"go.uber.org/zap"
)

var logger *zap.Logger

func init() {
	logger, _ = zap.NewProduction()
}

func fastHttpHandler(ctx *fasthttp.RequestCtx) {
	logger.Info("hello, go module", zap.ByteString("uri", ctx.RequestURI()))
}

func main() {
	fasthttp.ListenAndServe(":8081", fastHttpHandler)
}
```

这个示例用于创建一个在 8081 端口监听的 http 服务，当我们向它发起请求后，这个服务会在终端输出一段访问日志。

不过，当我们尝试编译这个源文件，go 编译器的输出结果是这样的：

```
main.go:4:2: no required module provides package github.com/valyala/fasthttp: go.mod file not found in current directory or any parent directory; see 'go help modules'
main.go:5:2: no required module provides package go.uber.org/zap: go.mod file not found in current directory or any parent directory; see 'go help modules'
```

可以看到，main.go 文件编译失败了。从编译器来看，go build 需要找 go.mod 的文件，来解决程序对第三方包的依赖决策问题。

go.mod 文件是 Go Module 的核心文件，在这个文件中存储了这个 module 对第三方依赖的全部信息。

> Go Module 构建模式是在 Go 1.11 版本正式引入的，目的是彻底解决 Go 项目复杂版本依赖的问题，在 Go 1.16 版本中，Go Module 已经成为 Go 默认的包依赖管理机制和 Go 源码构建机制。

接下来我们通过下面命令为这个示例程序添加 go.mod 文件。

```
go mod init github.com/bigwhite/hellomodule
```

```
go: creating new go.mod: module github.com/bigwhite/hellomodule
go: to add module requirements and sums:
	go mod tidy
```

现在你应该可以看到，go mod init 命令的执行结果是在当前目录下生成一个 go.mod 文件：

```
cat go.mod
```

```
module github.com/bigwhite/hellomodule

go 1.19
```

其实，一个 module 就是一个包的集合，这些包和 module 一起打版本、发布和分发。go.mod 所在目录即 module 根目录。

现在我们的 go.mod 文件内容还比较简单，第一行内容是用于声明 module 路径（module path）的。而且，module 隐含了一个命名空间的概念，module 下每个包的导入路径都是有 module path 和包所在子目录的名字结合在一起构成。

另外，go.mod 的最后一行是一个 Go 版本指示符，用于表示这个 module 是在某个特定 Go 版本的 module 语义基础上编写的。

要想我们的程序正常运行，还需要在 go.mod 中添加 fasthttp 和 zap 这两个包的版本信息，我们可以手动添加，也可以使用 go mod tidy 命令，让 Go 工具自动添加：

```
go mod tidy
```

```
go: finding module for package go.uber.org/zap
go: finding module for package github.com/valyala/fasthttp
go: downloading github.com/valyala/fasthttp v1.43.0
go: downloading go.uber.org/zap v1.24.0
go: found github.com/valyala/fasthttp in github.com/valyala/fasthttp v1.43.0
go: found go.uber.org/zap in go.uber.org/zap v1.24.0
go: downloading go.uber.org/atomic v1.7.0
go: downloading go.uber.org/multierr v1.6.0
go: downloading github.com/pkg/errors v0.8.1
go: downloading github.com/stretchr/testify v1.8.0
go: downloading github.com/klauspost/compress v1.15.9
go: downloading github.com/andybalholm/brotli v1.0.4
go: downloading github.com/valyala/bytebufferpool v1.0.0
go: downloading go.uber.org/goleak v1.1.11
go: downloading gopkg.in/yaml.v3 v3.0.1
go: downloading github.com/davecgh/go-spew v1.1.1
go: downloading github.com/pmezard/go-difflib v1.0.0
go: downloading github.com/benbjohnson/clock v1.1.0
```

丛输出结果中，可以看到 Go 工具不仅下载并添加了 hellomodule 直接依赖的 zap 和 fasthttp 包信息，还下载了这两个包的依赖包。

go mod tidy 执行完毕后，我们 go.mod 最新内容如下：

```go
module github.com/bigwhite/hellomodule

go 1.19

require (
	github.com/valyala/fasthttp v1.43.0
	go.uber.org/zap v1.24.0
)

require (
	github.com/andybalholm/brotli v1.0.4 // indirect
	github.com/klauspost/compress v1.15.9 // indirect
	github.com/valyala/bytebufferpool v1.0.0 // indirect
	go.uber.org/atomic v1.7.0 // indirect
	go.uber.org/multierr v1.6.0 // indirect
)
```

这个时候，go.mod 已经记录了 hellomodule 直接依赖的包信息。不仅如此，hellomodule 目录下还多了一个名为 go.sum 的文件，这个文件记录了 hellomodule 的直接依赖和间接依赖的相关版本的 hash 值，用来校验本地宝的真实性。在构建的时候，如果本地依赖包的 hash 值与 go.sum 文件中记录的不一致，就会被拒绝构建。

有了 go.mod 以及 hellomodule 依赖的包版本信息后，我们再来执行构建：

```
go build main.go
```

这次我们就可以成功构建出可执行文件 main，运行这个文件，新建一个终端端口，在新窗口中使用 curl 命令访问该服务，我们就可以看到服务端输出如下日志。

```
curl localhost:8081/foo/bar
```

```
{"level":"info","ts":1672627109.641545,"caller":"hellomodule/main.go:15","msg":"hello, go module","uri":"/foo/bar"}
```

现在我们的 “hello module” 程序就已经创建成功。我们也可以看到使用 Go Module 的构建模式，go build 完全可以承担起构建规模较大、依赖复杂的 Go 项目的重任。

### 总结

本篇文章，我们通过 helloworld 示例程序，了解了一个 Go 程序的源码结果与代码风格自动化格式的约定。

* Go 包是 Go 语言的基本组成单元。一个 Go 程序就是一组包的集合，所有 Go 代码都位于包中；
* Go 源码可以导入其他 Go 包，并使用其中的导出语法元素，包括类型、变量、函数、方法等，而且，main 函数是整个 Go 应用的入口函数；
* Go 语言需要先编译，然后再分发和运行。如果是单 Go 源文件的情况，我们可以使用 go build 命令和 Go 源文件名的方式进行编译。不过，对于复杂的 Go 项目，我们需要在 Go Module 的帮助下完成项目构建。

最后，我们集合 hellomodule 示例，初步歇息了如何构建更大规模的 Go 程序，并介绍了 Go Module 涉及的相关概念。

### 技术拓展

**go 引入其他包，是将引用包都编译进去，还是会引用动态连接库？**

go 默认是开启 CGO_ENABLED 的，将 CGO_ENABLED=1。但编译出来的二进制程序究竟有无动态连接，取决于你的程序使用了什么包。如果只是一个简单的 hello world，那么编译出来的将是一个纯静态程序。

如果你依赖了网络包或一些系统包，那么编译出来的二进制程序中将会是一个包含动态链接的库。

原因就是在目前的 go 标准库中，某些功能具有两份实现，一份是 c 语言实现的，一份是 go 语言实现的。在 CGO_ENABLE 开启的情况下，go 链接器会链接 c 语言的版本，于是就有了动态连接库的情况。如果将 CGO_ENABLED 置为 0 ，再重新编译链接，那么 go 链接器会使用 go 版本的实现，这样就会得到一个没有动态链接的纯静态二进制程序。

## Go 项目的布局标准

在前面的讲解中，我们编写的 Go 程序都是简单程序，一般由一个或几个 Go 源码文件组成，而且所有源码文件都在同一个目录中。但是生产环境中运行的实用程序并不会这么简单，通常它们都有复杂的项目结构布局。所以，弄清楚一个实用 Go 项目的项目布局标准是 Go 开发者走向编写复杂 Go 程序的第一步，也是必经的一步。

但是，Go 官方到目前为止也没有给出一个关于 Go 项目布局标准的正式定义。在这样的情况下，Go 社区是否有我们可以遵循的参考布局，或者事实标准？

答案是肯定的，在本节课中，我们就来学习一下 Go 社区广泛采用的 Go 项目布局是什么样子的。

要想了解 Go 项目的结构布局以及演化历史，全世界第一个 Go 语言项目是一个最好的切入点。所以，我们就先来看一下 Go 语言 “创世项目” 的结构布局是什么样子。

### “创世项目” 结构

所谓 “Go 语言的创世项目”，其实就是 Go 语言项目自身，它是全世界第一个 Go 语言项目。不过这么说也不够精确，因为 Go 语言项目起初混杂着多种语言，以 C 和 Go 代码为主，Go 语言的早期版本 C 代码的比例还不小。

我们可以使用 [loccount 工具](https://gitlab.com/esr/loccount) 对 Go 语言发布的第一个 [Go 1.0 版本](https://github.com/golang/go/releases/tag/go1) 分析：

```
locccount .
```

```
all          SLOC=460992  (100.00%)  LLOC=193045  in 2746 files
Go           SLOC=256321  (55.60%)  LLOC=109763  in 1983 files
C            SLOC=148001  (32.10%)  LLOC=73458   in 368 files
HTML         SLOC=25080   (5.44%)  LLOC=0       in 57 files
asm          SLOC=10109   (2.19%)  LLOC=0       in 133 files
... ...
```

你会发现，在 1.0 版本中，Go 代码行数占据一半以上比例，但是 C 语言代码行数也占据 32.10% 的份额。并且在后续 Go 版本演进过程中，Go 语言代码行数占比还在逐步提升，直到 Go 1.5 版本实现自举后，Go 语言代码行数占比近 90%，C 语言比例下降为不到 1%，这一比例一直持续至今。

虽然 C 代码比例下降，Go 代码比例上升，但 Go 语言项目的布局结构却整体保留下来，十多年间虽然也有一些小范围变动，但整体没有本质变化。作为 Go 语言的 “创世项目”，它的结构布局对后续 Go 社区的项目具有重要的参考价值，尤其是 Go 项目早期 src 目录下面的结构。

为了方便查看，我们可以下载 Go 语言项目源码：

```
git clone https://github.com/golang/go.git
```

以 Go 1.3 版本为例，结果是这样的：

```
cd go // 进入Go语言项目根目录
git checkout go1.3 // 切换到go 1.3版本

tree -LF 1 ./src // 查看src目录下的结构布局
./src
├── all.bash*
├── clean.bash*
├── cmd/
├── make.bash*
├── Make.dist
├── pkg/
├── race.bash*
├── run.bash*
... ...
└── sudo.bash*
```

从上面的结果来看，src 目录下结构有三个特点。

首先，你可以看到，以 all.bash 为代表的代码构建的脚本源文件放在 src 下面的顶层目录。

其次，src 下的二级目录 cmd 下面存放 Go 相关可执行文件的相关目录，我们可以继续深入查看 cmd 目录下的结构：

```
tree -LF 1 ./cmd

./cmd
... ...
├── 6a/
├── 6c/
├── 6g/
... ...
├── cc/
├── cgo/
├── dist/
├── fix/
├── gc/
├── go/
├── gofmt/
├── ld/
├── nm/
├── objdump/
├── pack/
└── yacc/
```

我们可以看到，这里的每个子目录都是一个 Go 工具链命令子命令对应的可执行文件。其中，6a、6c、6g 等是早期 Go 版本针对特定平台的汇编器、编译器等的特殊命名方式。

最后，你会看到 src 下的二级目录 pkg 下面存放着运行时实现、标准库包实现，这些包即可以被上面 cmd 下各程序所导入，也可以被 Go 语言项目之外的 Go 程序依赖并导入。下面是我们通过 tree 命令查看 pkg 下面结构的输出结果：

```
tree -LF 1 ./pkg

./pkg
... ...
├── flag/
├── fmt/
├── go/
├── hash/
├── html/
├── image/
├── index/
├── io/
... ...
├── net/
├── os/
├── path/
├── reflect/
├── regexp/
├── runtime/
├── sort/
├── strconv/
├── strings/
├── sync/
├── syscall/
├── testing/
├── text/
├── time/
├── unicode/
└── unsafe/
```

虽然 Go 语言的创世项目的 src 目录下的布局结构，距离现在已经比较久远，但是这样的布局特点依然对后续很多 Go 项目的布局产生比较大的影响，尤其是那些 Go 语言早期采纳者建立的 Go 项目。比如，Go 调试器项目 Delve、开启云原生时代的 Go 项目 Docker，以及云原生时代的 “操作系统” 项目 Kubernetes 等，它们的项目布局，至今都还保持与 Go 创世项目早期相同的风格。

当然，这些早期的布局结构一直在不断地演化，简单来说可以归纳为下面三个比较重要的演进。

**演进一：Go 1.4 版本删除 pkg 这一中间层目录并引入 internal 目录**

出于简化源码树层次原因，Go 语言项目的 Go 1.4 版本对它原来的 src 目录下的布局做了两处调整。第一处是删除了 Go 源码中 “src/pkg/xxx” 中 pkg 这一层级目录而直接使用 src/xxx。这样一来，Go 语言项目的源码树深度减少一层，更便于 Go 开发者阅读和探索 Go 项目源码。

另外一处就是 Go 1.4 引入 internal 包机制，增加了internal 目录。这个 internal 机制其实是所有 Go 项目都可以用的，Go 语言项目自身也是自 Go 1.4 版本起，就使用 internal 机制。根据 internal 机制定义，一个 Go 项目里的 internal 目录下的 Go 包，只可以被本项目内部的包导入。项目外部是无法导入这个 internal 目录下面的包的。可以说，internal 目录的引入，让一个 Go 项目中 Go 包的分类与用途变得更加清晰。

**演进二：Go 1.6 版本增加 vendor 目录**

第二次演进，其实是为了解决 Go 包依赖版本管理的问题，Go 核心团队在 Go 1.5 版本中做了第一次改进。增加了 vendor 构建机制，也就是 Go 源码的编译可以不在 GOPATH 环境变量下搜索依赖包的路径，而在 vendor 目录下查找对应的依赖包。

Go 语言项目自身也在 Go 1.6 版本中增加了 vendor 目录以支持 vendor 构建，但 vendor 目录并没有实质性缓存任何第三方包。直到 Go 1.7 版本，Go 才真正在 vendor 下缓存其依赖的外部包。这些依赖包主要是 golang.org/x 下面的包，这些包同样是由 Go 核心团队维护的，并且其更新速度不受 Go 版本发布周期影响。

vendor 机制与目录的引入，让 Go 项目第一次具有可重现构建（Reproducible Build）的能力。

> 可重现构建，就是针对同一份 go module 源码进行构建，不同人，在不同机器（同一架构），相同 os 上，在不同时间点都能得到相同的二进制文件。

**演进三：Go 1.13 版本引入 go.mod 和 go.sum**

第三次演进，还是为了解决 Go 包依赖版本管理的问题。在 Go 1.11 版本中，Go 核心团队做出了第二次改进尝试：引入 Go Module 构建机制，也就是在项目引入 go.mod 以及在 go.mod 中明确项目所依赖的第三方包和版本，项目的构建就将摆脱 GOPATH 的束缚，实现精准的可重现构建。

Go 语言项目自身在 Go 1.13 版本中引入 go.mod 和 go.sum 以支持 Go Module 构建机制，下面是 Go 1.13 版本的 go.mod 文件内容：

```
module std

go 1.13

require (
  golang.org/x/crypto v0.0.0-20190611184440-5c40567a22f8
  golang.org/x/net v0.0.0-20190813141303-74dc4d7220e7
  golang.org/x/sys v0.0.0-20190529130038-5219a1e1c5f8 // indirect
  golang.org/x/text v0.3.2 // indirect
)
```

可以看到，Go 语言项目自身所依赖的包在 go.mod 中都有对应的信息，而原本这些依赖包是缓存在 vendor 目录下的。

总的来说，这三次演进主要体现在简化结构布局，以及优化包依赖管理方面，起到改善 Go 开发体验的作用。可以说，Go 创世项目的源码布局以及演化对 Go 社区项目的布局具有重要的启发意义，以至于在多年的 Go 社区实践后，Go 社区逐渐形成公认的 Go 项目的典型结构布局。

### 典型结构布局

一个 Go 项目通常分为可执行程序项目和库项目，现在我们就来分析一下这两类 Go 项目的典型结构布局分别是怎样的。

#### Go 可执行程序

首先来看一下 Go 可执行程序项目的典型结构布局。

可执行程序项目是以构建可执行程序为目的项目，Go 社区针对这类 Go 项目所形成的典型结构布局是这样的：

```
tree -F exe-layout 

exe-layout
├── cmd/
│   ├── app1/
│   │   └── main.go
│   └── app2/
│       └── main.go
├── go.mod
├── go.sum
├── internal/
│   ├── pkga/
│   │   └── pkg_a.go
│   └── pkgb/
│       └── pkg_b.go
├── pkg1/
│   └── pkg1.go
├── pkg2/
│   └── pkg2.go
└── vendor/
```

上面这样的一个 Go 项目典型布局就是 “脱胎” 于 Go 创世项目的最新结构布局。下面我们就来解释一下这里面的几个要点。

我们从上往下按顺序来，首先来看 cmd 目录。cmd 目录存放项目要编译的可执行文件对应的 main 包的源文件。如果你的项目中有多个可执行文件需要构建，每个可执行文件的 main 包需要单独放在一个子目录中。比如图中的 app1、app2，cmd 目录下的各 app 的 main 将整个项目的依赖连接在一起。

通常来说，main 包应该很简洁。我们在 main 包中会做一些命令行参数解析、资源初始化、日志设施初始化、数据库连接初始化等工作，之后就会将程序的执行权限交给更高级的执行控制对象。另外，也有一些 Go 项目会将 cmd 这个名字改为 app 或其他名字，但它的功能并没有变。

接下来看 pkg* 目录，这是一个存放项目自身要使用，同样也是可执行文件对应 main 包所依赖的库文件，同时这些目录下的包还可以被外部项目引用。

然后是 go.mod 和 go.sum ，它们是 Go 语言包依赖管理使用的配置文件。我们之前说过，Go 1.11 版本引入了 Go Module 构建机制，建议新项目都基于 Go Module 进行包依赖管理，这是目前 Go 官方推荐的标准构建模式。

对于还没有使用 Go Module 进行包依赖管理的遗留项目，比如之前采用 dep、glide 等作为包依赖管理功能的，建议尽快迁移到 Go Module 模式。Go 命令支持将 dep 的 Gopkg.toml/Gopkg.lock 或 glide 的 glide.yaml/glide.lock 转换为 go.mod。

最后我们再来看看 vendor 目录。vendor 是 Go 1.5 版本引入的用于在项目本地缓存特定八本依赖包的机制，在 Go Modules 机制引入前，基于 vendor 可以实现可重现构建，保证基于同一源码构建出的可执行程序是等价的。

不过，这里可以将 vendor 目录视为一个可选目录。原因在于，Go Modue 本身就支持可再现构建，而无需使用 vendor。当然 Go Module 机制也保留了 vendor 目录（通过 go mod vendor 可以生成 venfor 下的依赖包，通过 go build -mod=vendor 可以实现基于 vendor 的构建）。一般我们仅包里项目根目录下的 vendor 目录，否则会造成不必要的依赖选择的复杂性。

当然，还有些开发者喜欢借助一些第三方的构建工具辅助构建，比如 make、bazel 等。你可以将这些外部辅助构建工具涉及的诸多脚本文件（比如 Makefile）放置在项目的顶层目录下，就像 Go 创世项目中的 all.bash 那样。

另外，Go 1.11 引入的 module 是一组同属于一个版本管理单元。的包的集合。并且 Go 支持在一个项目/仓库中存在多个 module，但这种管理方式可能要比一定比例的代码重复引入更多的复杂性。因此，如果项目结构中存在版本管理的 “分歧”，比如：app1 和 app2 的发布版本并不总是同步的，建议你讲项目拆分为多个项目（仓库），每个项目单独作为一个 module 进行单独的版本管理和演进。

当然如果你非要在一个代码仓库中存放多个 module，新版 Go 命令也提供了很好的支持。比如下面代码仓库 multi-modules 下面有三个 module：mainmodule、module1、module2 ：

```
tree multi-modules

multi-modules
├── go.mod // mainmodule
├── module1
│   └── go.mod // module1
└── module2
    └── go.mod // module2
```

我们可以通过 git tag 名字来区分不同 module 版本。其中 vX.Y.Z 形式的 tag 名字用于代码仓库下的 mainmodule；而 module1/vX.Y.Z 形式的 tag 名字用于指示 module1 的版本；同理 module2/vX.Y.Z 形式的 tag 名字用于指示 module2 版本。

如果 Go 可执行程序项目有一个且只有一个可执行程序要构建，我们还可以将上面项目布局进行简化：

```
tree -F -L 1 single-exe-layout

single-exe-layout
├── go.mod
├── internal/
├── main.go
├── pkg1/
├── pkg2/
└── vendor/
```

你可以看到，我们可以删除 cmd 目录，将唯一的可执行程序的 main 包放在项目根目录下，其他布局元素的功能不变。

#### Go 库项目

到现在，我们已经了解 Go 可执行程序项目的典型布局，现在我们再来看下 Go 库项目的典型布局是怎样的。

Go 库项目仅对外暴露 Go 包，这类项目的典型布局形式是这样的：

```
tree -F lib-layout 

lib-layout
├── go.mod
├── internal/
│   ├── pkga/
│   │   └── pkg_a.go
│   └── pkgb/
│       └── pkg_b.go
├── pkg1/
│   └── pkg1.go
└── pkg2/
    └── pkg2.go
```

我们可以看到，库类型项目相比 Go 可执行程序的布局要简单一些。因为这类项目不需要构建可执行程序，所以去除了 cmd 目录。

并且，在这里，vendor 也不再是可选目录。对于库类型项目而言，我们并不推荐在项目中放置 vendor 目录去缓存库自身的第三方依赖，库项目仅通过 go.mod 文件明确表述出该项目依赖的 modue 或包以及版本要求就可以了。

Go 库项目的初衷是为了对外部（开源或组织内部公开）暴露 API，对于仅限项目内部使用而不像暴露到外部的包，可以放在项目顶层的 internal 目录下面。在同一项目中，internal 也可以有多个并存在于项目结构中的任意目录层级，关键是项目结构设计人员要明确各级 internal 包的应用层次和范围。

对于有一个且仅有一个包的 Go 库项目来说，我们也可以将上面的布局做进一步简化：

```
tree -L 1 -F single-pkg-lib-layout

single-pkg-lib-layout
├── feature1.go
├── feature2.go
├── go.mod
└── internal/
```

简化后，我们可以将唯一包的所有源文件放置在项目的顶层目录下，其他布局元素位置和功能不变。

我们已经了解目前 Go 项目的典型结构布局。除此之外，我们还需要注意一下早期 Go 可执行程序项目的经典布局。

### 早期 Go 可执行程序

很多早期接纳 Go 语言的开发者所建立的 Go 可执行程序项目，深受 Go 创世项目 1.4 版本之前的布局影响，这些项目将所有可暴露到外面的 Go 包聚合在 pkg 目录下，就像前面 Go 1.3 版本中的布局那样。

```
tree -L 3 -F early-project-layout

early-project-layout
└── exe-layout/
    ├── cmd/
    │   ├── app1/
    │   └── app2/
    ├── go.mod
    ├── internal/
    │   ├── pkga/
    │   └── pkgb/
    ├── pkg/
    │   ├── pkg1/
    │   └── pkg2/
    └── vendor/
```

我们可以看到，原本放在项目根目录的 pkg1 和 pkg2 公共包被统一聚合到 pkg 目录下。而且，这种早期 Go 可执行程序的典型布局在 Go 社区内部也不缺少受众，很多新建的 Go 项目依然采用这样的项目布局。

### 总结

在这篇文章中，我们学习了 Go 创世项目，即 Go 语言项目自身的项目源码布局，以及演进情况。在 Go 创世项目的启发下，Go 社区在多年实践中形成了典型的 Go 项目结构布局形式。

我们将 Go 项目分为可执行程序项目和 Go 库项目两类进行了详细的项目经典布局讲解。

首先，对于以生产可执行程序为目的的 Go 项目，它的典型项目结构分为五部分：

* 项目顶层的 Go Module 相关文件，包括 go.mod 和 go.sum；
* cmd 目录：存放项目要编译构建的可执行文件所对应的 main 包的源码文件；
* 项目包目录：每个项目下的非 main 包都平铺在项目的根目录下，每个目录对应一个 Go 包；
* internal 目录：存在仅项目内部引用的 Go 包，这些包无法被项目之外引用；
* vendor 目录：可选目录，为了兼容 Go 1.5 引入的 vendor 构建模式而存在。这个目录下的内容均由 Go 命令自动维护，不需要手动干预。

其次，对于以生产可复用库为目的的 Go 项目，它的典型结构简单许多，我们可以直接理解为在 Go 可执行程序项目的基础上去掉 cmd 目录和 vendor 目录。

最后，早期接纳 Go 语言的开发者所建立的项目布局深受 Go 创世项目 1.4 版本之前布局的影响，将可导出的公共包放入单独的 pkg 目录下，对于这种情况我们了解即可。对于新建项目，还是建议采用前面介绍的标准布局形式。

## 构建模式：包依赖管理问题

我们已经初步了解 Go 程序的结构，以及 Go 项目的典型布局。接下来，我们来系统学习下 Go 应用的构建。

通过这篇文章，我们可以了解 Go 构建模式演化的前世今生。理解这个发展史后，我们再来重点探讨现在被广泛采用的构建模式，Go Module 的基本概念和应用构建方式。知道怎么做之后，我们会继续分析 Go Module 的工作原理。经过层层深入地分析，你就能彻底、透彻地掌握 Go Module 构建模式。

我们先来了解一下 Go 构建模式的演化过程，弄清楚 Go 核心开发团队为什么要引入 Go Module 构建模式。

### Go 构建模式演化过程

Go 程序由 Go 包组合而成，Go 程序的构建过程就是确定包版本、编译包以及编译后得到的目标文件链接在一起的过程。

Go 语言的构建模式历经了三个迭代和演化过程，分别是初期的 GOPATH、1.5 版本的 Vendor 机制，以及现在的 Go Module。

#### GOPATH

Go 语言在首次开源时，就内置了一种名为 GOOPATH 的构建模式。在这种构建模式下，Go 编译器可以在本地 GOPATh 环境变量配置的路径下，搜寻 Go 程序依赖的第三方包。如果存在，就使用这个本地包进行编译；如果不存在，就会报编译错误。

这里给出一段在 GOPATH 构建模式下编写的代码：

```go
package main

import "github.com/sirupsen/logrus"

func main() {
  logrus.Println("hello, gopath mode")
}
```

你可以看到，这段代码依赖第三方包 logrus（logrus 是 Go 社区使用最为广泛的第三方 log 包）。

接下来，这个构建过程演示 Go 编译器在 GOPATH 环境变量所配置的目录下，无法找到程序依赖的 logrus 包而报错的情况：

```
go build main.go

main.go:3:8: cannot find package "github.com/sirupsen/logrus" in any of:
  /Users/heora/.bin/go1.10.8/src/github.com/sirupsen/logrus (from $GOROOT)
  /Users/heora/Go/src/github.com/sirupsen/logrus (from $GOPATH)
```

那么 Go 编译器在 GOPATH 构建模式下，是如何搜寻第三方依赖包呢？

我们先假定 Go 程序导入了 github.com/user/repo 这个包，我们也同时假定当前 GIOPATH 环境变量配置的值为：

```
export GOPATH=/usr/local/goprojects:/home/heora/go
```

在 GOPATH 构建模式下，Go 编译器在编译 Go 程序时，就会在下面两个路径下搜索第三方依赖包是否存在：

```
/usr/local/goprojects/src/github.com/user/repo
/home/heora/go/src/github.com/user/repo
```

> 如果没有显式设置 GOPATH 环境变量，不同操作系统下默认值的路径不同，在 macOS 或 Linux 上，默认值都是 $HOME/go。

言归正传，当遇到上面例子这样，没有在本地找到程序的第三方包的情况，我们该如何解决这个问题？

这个时候就要用到 go get。

我们可以通过 go get 命令将本地缺失的第三方依赖包下载到本地，比如：

```
go get github.com/sirupsen/logrus
```

这里的 go get 命令，不仅能将 logrus 包下载到 GIOPATH 环境变量配置的目录下，它还会检查 logrus 的依赖包在本地是否存在，如果不存在，go get 也会一并将它们下载到本地。

不过，go get 下载的包是在那个时刻的最新主线版本，这样会给后续 Go 程序的构建带来一些问题。例如：

* 依赖包持续演进，可能会导致不同开发者在不同时间获取和编译同一个 Go 包时，得到不同的结果，不能保证可重现构建（Reproduceable Build）。
* 如果依赖包引入不兼容代码，程序将无法通过编译。
* 如果依赖包因引入新代码而无法正常通过编译，并且该依赖包作者又没及时修复这个问题，这种错误也会导致程序无法通过编译。

#### vendor 机制

在 GOPATH 构建模式下，Go 编译器实质上并没有关注 Go 项目所依赖的第三方包的版本。但 Go 开发者希望自己的 Go 项目所依赖的第三方包版本可以受自己的控制，而不是随意变化。于是 Go 核心开发团队引入 Vendor 机制试图解决上面的问题。

现在我们就来看看 vendor 机制是如何解决这个问题的。

Go 在 1.5 版本中引入 vendor 机制。vendor 机制本质上就是在 Go 项目的某个特定目录下，将项目的所有依赖包缓存起来，这个特定目录名就是 vendor。

Go 编译器会优先感知和使用 vendor 目录下缓存的第三方包版本，而不是 GOPATH 环境变量所配置的路径下的第三方包版本。这样，无论第三方依赖包自己如何变化，无论 GOPATH 环境变量所配置的路径下的第三方包是否存在、版本是什么，都不会影响 Go 程序的构建。

如果你将 vendor 目录和项目源码一样提交到代码仓库，那么其他开发者下载你的项目后，就可以实现可重现的构建。因此，如果使用 vendor 机制管理第三方依赖包，最佳实践就是将 vendor 一并提交到代码仓库中。

下面这个目录结构就是添加 vendor 目录后的结果：

```
.
├── main.go
└── vendor/
    ├── github.com/
    │   └── sirupsen/
    │       └── logrus/
    └── golang.org/
        └── x/
            └── sys/
                └── unix/
```







