# Tony Bai - Go语言第一课

## 推荐入坑理由

* 对初学者足够友好，能够快速上手
  * 语法简单，可以快速学习语法，编写简单、实用应用
  * 设计者在发布 Go 1.0 版本和兼容性规范后，主要精力还是打磨 Go 实现，改进周边工具链
* 生产力与性能的最佳组合
  * 创建最初目的，就是构建流行的、高性能的服务端编程语言
  * 性能也有明显优势，与不带 GC 的静态编程语言（C/C++）之间也没有数量级的差距
  * 对于动态语言用户友好，并且和动态语言相比，可以在保持生产力的同时，大幅度提高性能
  * 在云原生基础设施、中间件与云服务领域大放异彩
  * 可以应用在 DevOps/SRE、区块链、命令行交互程序（CLI）、Web 服务，数据处理方面
* 快乐且具有前景
  * 相对于 C/C++、Java，Go 在开发体验上有很多提升，包括简单的语法、得心应手的工具链、丰富和健壮的标准库，生产力与性能的完美结合，免除内存管理的心智负担，对并发设计的原生支持等等
  * 可以使用 Go 体现自身价值，有非常广泛的应用场景

## GO 历史与现状

### Go 语言是怎样诞生的

Go 语言的创始人有三位，分别是图灵奖获得者、C 语言联合发明人、Unix 之父肯·汤普森（Ken Thompson ），Plan 9 操作系统领导者、UTF - 8 编码的最初设计者罗伯·派克（Rob Pike），以及 Java 的 HotSpot 虚拟机和 Chrome 浏览器的 JavaScript V8 引擎的设计者之一罗伯特·格瑞史莫（Robert Griesemer）。

他们三个人在 2007 年 9 月 20 日下午的一次普通讨论，成了计算机编程语言领域的一次著名历史事件，开启了一个新编程语言的历史。

在谷歌山景城总部的办公室里，罗伯 · 派克启动了一个 C++ 工程的构建，根据以往的经验，这次构建大约需要一个小时。利用这段时间，罗伯·派克和罗伯特·格瑞史莫、肯·汤普森坐在一起，交换了关于设计一门新编程语言的想法。

之所以产生这种想法，是因为当时谷歌内部主要适用 C++ 语言构建各种系统，但 C++ 的巨大复杂性，编译构建速度慢以及在编写服务端程序时对并发支持的不足，让三位大佬觉得非常不便，于是他们就想着设计一门新的语言。在他们的初步构想中，这门新语言应该是能够给程序员带来快乐、匹配未来硬件发展趋势并适合用来开发谷歌大规模网络服务程序的。

在一天的简短讨论后，第二天三位大佬具体讨论了这门新语言的设计。会后罗伯特·格瑞史发出电邮，对这门新编程语言的功能特性做了初步归纳总结。主要思路是，在 C 语言的基础上，修正一些明显的缺陷，删除一些被诟病较多的特性，增加一些缺失的功能。例如，使用 import 替代 include、去掉宏、增加垃圾回收、支持接口等。这封电邮成为这门新语言的第一版特性设计稿，三位大佬在这门语言的一些基础语法特性上达成初步一致。

9 月 25 日，罗伯·派克在一封回复电邮中把这门新编程语言命名为 “go”。在罗伯 · 派克的心目中，“go” 这个单词短小、容易输入并且在组合其他字母后便可以用来命名 Go 相关的工具，比如编译器（goc）、汇编器（goa）、链接器（gol）等。

> go 早期版本曾如此命名 go 工具链，但后续版本撤销了这种命名方式，仅保留 go 这一统一的工具链名称。

另外，很多 Go 语言初学者经常称这门语言为 Golang，其实这是不对的：“Golang” 仅应用于命名 Go 语言官网网站，没有使用 go.com 纯粹是因为这个域名被占用了而已。

### “三人行” 到 ”众人拾柴“

经过早期讨论，Go 语言的三位作者在语言设计达成初步一致后，便开启了 Go 语言迭代设计和实现的过程。

2008 年初，Unix 之父肯·汤普森实现了第一版 Go 编译器，用于验证之前的设计。这个编译器先将 Go 代码转换为 C 代码，再由 C 编译器编译成二进制文件。

2008 年年中，Go 的第一版设计就基本结束了。这是，同样在谷歌工作的伊恩·泰勒（Ian Lance Taylor）为 Go 语言实现了一个 gcc 的前端，这也是 Go 语言的第二个编译器。伊恩·泰勒的成本不仅仅是一种鼓励，也证明了 Go 这一新语言的可行性。随后，伊恩·泰勒以团队第四位成员的身份正式加入 Go 语言开发团队，后面也成了 Go 语言，以及其工具设计和实现的核心人物之一。

> 一个编译器的完整编译过程包括：词法分析、语法分析、类型检查、中间代码生成、代码优化、目标代码生成、目标代码优化等几个阶段。从词法分析到中间代码生成，这就是编译器前端所要负责的事情。代码优化和目标代码生成，则是编译器后端的职责。
>
> 上面所说的实现 gcc 的前端，就是实现一个程序，这个程序可以读取 go 源码并通过词法分析、语法分析、类型检查，最终生成中间代码，而这个中间代码可以被 gcc 后端所识别并生成最终目标代码。

罗斯·考克斯（Russ Cox）是 Go 核心开发团队的第五位成员，也是在 2008 年加入。随后，罗斯·考克斯利用函数是 “一等公民”，并且它也可以拥有自己的方法这一特性设计出了 http 包的 HandlerFunc 类型。这样，我们通过显式转型就可以让一个普通函数称为满足 http.Handler 接口的类型。

> 在 Go 中，如果一个变量的类型为 int，如果我们要将其与另一个 int 64 类型的变量进行加法运算，我们不能直接将它们相加，我们必须将它们显示的转换为同一类型后才能想家，这里的转换过程就简称为显式转型。

不仅如此，罗斯·考克斯还在当时设计的基础上提出一些更泛化的想法，比如 io.Reader 和 io.Writer 接口，这就奠定了 Go 语言的 I/O 结构模型。后来，罗斯·考克斯成为 Go 核心技术团队的负责人，推动 Go 语言的持续演化。

至此，Go 语言最初的核心团队形成，Go 语言迈上稳定演化的道路。

2009 年 10 月 30 日，罗伯·派克在 Google Techtalk 上做了一次有关 Go 语言的演讲，“The Go Programming Language”，这是 Go 语言第一次公之于众。十天后，2009 年 11 月 10 日，谷歌官方宣布 Go 语言项目开源，之后这一天也被 Go 官方确定为 Go 语言的诞生日。

在 Go 语言项目开源后，Go 语言也迎来了自己的 “吉祥物”，是一只由罗伯·派克夫人芮妮·弗伦奇（Renee French）设计的地鼠，从此地鼠（gopher）也就成为了世界各地 Go 程序员的象征，Go 程序员也被昵称为 Gopher。

<img src="./images/go.png" />

Go 语言项目的开源吸引了全世界开发者的目光，再加上 Go 三位作者在业界的影响力以及谷歌这座大树的加持，更多有才华的程序员加入到 Go 核心开发团队中，更多贡献者开始为 Go 语言项目添砖加瓦。于是，Go 在宣布开源的当年，就成为了著名编程排行榜 TIOBE 的年度编程语言。

2012 年 3 月 28 日，Go 1.0 版本正式发布，同时 Go 官方发布了 “Go 1 兼容性” 承诺：只要符合 Go 1 语言规范的源代码，Go 编译器将保证向后兼容（backwards compatible），也就是说我们使用新版编译器也可以正确编译用老版本语法编写的代码。

从正式开源到现在，Go 语言发布了多个大版本更新，逐渐成熟。下面梳理了迄今为止 Go 语言的重大版本更新，希望可以帮助你快速了解 Go 语言的演化历史。

<img src="./images/go_history.png" />

经过十余年的打磨与优化，如何的 Go 语言已经逐渐成为云计算时代基础设施的编程语言。你能想到的现代云计算基础设施软件的大部分流行和可靠的作品，都是用 Go 编写的，比如：Docker、Kubernetes、Prometheus、Ethereum（以太坊）、lstio、CockroachDB、InfluxDB、Terraform、Etcd、Consul 等等，可以看 Go 语言的影响力已经十分强大。

### 总结

一门编程语言的历史和现状，可以给你带来学习的 “安全感”，相信它可以提升你的个人价值，也会让你获得丰富的回报。你也会更加清楚地认识到：自己为什么要学习它？它未来的发展趋势又是怎样的？当这门语言的现状能给予你极大 “安全感” 的时候，我们才会 “死心塌地” 地学习和钻研这门技术，不会有太多的后顾之忧。

从 Go 本身的发展来看，和多数编程语言一样，Go 语言在诞生后，度过了一个较长 “技术萌芽期”。然后，实现了自举，发布对 GC 延迟进行大幅优化的 Go 1.5 版本，成为 Go 语言演化过程中的第一个 “引爆点”，推动 Go 语言进入 “技术膨胀期”。

也正是在这段时间内，Go 语言推出了以 Docker、Kubernetes 为典型代表的 “杀手级应用”，充分展示了实力，在世界范围收获了百万粉丝，迸发出极高的潜力和持续的活力。

## Go 语言的设计哲学

很多编程语言的初学者在学习初期，可能都会遇到这样的问题：最初兴致勃勃地开始学习一门编程语言，学着学着就发现很多 “别扭” 的地方，比如想要的语言特性缺失、语法风格偏避与主流语言差异大、语言的不同版本之间无法兼容、语言的语法特性过多导致学习曲线陡峭、语言的工具链支持较差，等等。

以上的这些问题，本质上都与语言设计者的设计哲学有关。所谓编程语言的设计哲学，就是指决定这门语言演化进程的高级原则和依据。

设计哲学之余编程语言，就好比一个人的价值观之余这个人的行为。如果不认同这个人的价值观，那你就很难与之持续交往下去。同理，如果你不认同一门编程语言的设计哲学，那么大概率你会在后续的语言学习中，就会遇到上面提到的问题，而且可能会让你失去继续学习的精神动力。

因此，在正式学习 Go 语法和编码之前，我们还需要先来了解一下 Go 语言的设计哲学。

### 设计哲学

Go 语言的设计哲学可以总结为五点：简单、显式、组合、并发和面向工程。

#### 简单

Go 语言的设计者们在语言设计之初，就拒绝走语言特性融合的道路，选择 “做减法” 并致力于打造一门简单的编程语言。

这也就意味着 Go 不会像 C++、Java 那样将其他编程语言的新特性兼蓄并收，所以你在 Go 语言中看不到传统的面向对象的类、构造函数与继承，看不到结构化的异常处理，也看不到本属于函数编程范式的语法元素。

不过，Go 语也没它看起来那么简单，自身实现起来也并不容易，但这些复杂性都被 Go 语言的设计者们 “隐藏” 了，所以 Go 语法层面上呈现这样的状态：

* 仅有 25 个关键字，主流编程语言很少；
* 内置垃圾收集，降低开发人员内存管理的心智负担；
* 首字母大小写决定可见性，无需通过额外关键字修饰；
* 变量初始为类型零值，避免以随机值作为初值的问题；
* 内置数组边界检查，极大减少越界访问带来的安全隐患；
* 内置并发支持，简化并发程序设计；
* 内置接口类型，为组合的设计哲学奠定基础；
* 原生提供完善的工具链，开箱即用；
* ... ...

我们可以看到 Go 设计者选择的 “简单”，其实是站在巨人肩膀上，去除或优化了以往语言中，已经被开发者证明为体验不好或难以驾驭的语法元素和语言机制，并提出自己的一些创新性的设计。比如，首字母大小写决定可见性、变量初始为类型零值、内置以 go 关键字实现的并发支持等。

简单意味着可以使用更少的代码实现相同的功能，简单意味着代码具有更好的可读性，可读性好的代码通常意味着更好的可维护性以及可靠性。

简单的设计哲学是 Go 生产力的源泉。

#### 显式

首先，我们先来看一段 C 程序，看下 “隐式” 代码的行为特性。

在 C 语言中，下面这段代码可以正常编译并输出正确结果：

```c
#include <stdio.h>

int main() {
    short int a = 5;

    int b = 8;
    long c = 0;
    
    c = a + b;
    printf("%ld\n", c);
}
```

在上面这段代码中，变量 a、b 和 c 的类型均不相同，C 语言编译器在编译 c = a + b 这一行时，会自动将短整型变量 a 和整型变量 b，先转换成 long 类型然后相加，并将所有结果存储在 long 类型变量 c 中。

```go
package main

import "fmt"

func main() {
    var a int16 = 5
    var b int = 8
    var c int64

    c = a + b
    fmt.Printf("%d\n", c)
}
```

我们将上面的 C 程序转换为等价的 Go 代码，当编译程序时，会得到这样的编译器错误：“invalid operation：a + b（mismatched types int16 and in）”。我们能看到 Go 与 C 语言的隐式自动类型转换不同，Go 不允许不同类型的整型变量进行混合计算，它同样也不会对其进行隐式的自动转换。

因此，如果要使这段代码通过编译，我们就需要对变量 a 和 b 进行显式转型，就像下面这段代码：

```go
c = int64(a) + int64(b)
fmt.Printf("%d\n", c)
```

这其实就是 Go 语言显式设计哲学的体现。

在 Go 语言中，不同类型变量是不能在一起进行混合计算的，这是因为 Go 希望开发人员明确知道自己在做什么，你需要以显式的方式通过转型统一参与计算各个变量的类型。

初次之外，Go 设计者所崇尚的显式哲学还直接决定了 Go 语言错误处理的形态：Go 语言采用显式的基于值的错误处理方案，函数/方法中的错误都会通过 return 语句显式地返回，并且通常调用者不能忽略对返回的错误进行处理。

#### 组合

这个设计哲学和我们的各个程序之间的耦合有关，Go 语言不像 C++、Java 等主流面向对象语言，我们在 Go 中见不到经典的面向对象语法元素、类型体系和继承机制，Go 崇尚的是组合的设计哲学。

在 Go 语言设计层面，Go 设计者为开发者们提供正交的语法元素，以供后续组合使用，包括：

* Go 语言无类型层次体系，各类型之间是相互独立的，没有子类型的概念；
* 每个类型都可以有自己的方法集合，类型定义与方法实现是正交独立的；
* 实现某个接口时，无需像 Java 那样采用特定关键字修饰；
* 包之间是相互独立的，没有子包的概念。

> 正交指相互独立，不可替代，并且组合起来可实现其它功能。

无论是包、接口还是具体类型定义，GO 语言其实为我们呈现这样的一幅图景：一座座没有关联的 “孤岛”，但每个岛内又很精彩。Go 采用组合的方式在这些孤岛之间建立关联，形成一个整体。

Go 语言为支撑组合的设计提供了类型嵌入（Type Embedding）。通过类型嵌入，我们可以将已实现的功能嵌入到新类型中，以快速满足新类型的功能需求，这种方式有点类似面向对象语言中的 “继承” 机制，但在原理上完全不同，这是一种 Go 设计者们精心设计的 “语法糖”。

被嵌入的类型和新类型两者之间没有任何关系，甚至相互完全不知道对方的存在，没有面向对象语言中的那种父类、子类的关系，以及向上、向下转型（Type Casting）。通过新类型实例调用方法时，方法的匹配主要取决于方法名字，而不是类型。这种组合方式，可以称之为垂直组合，即通过类型嵌入，快速让一个新类型 “复用” 其他类型已经实现的能力，实现功能的垂直扩展。

下面是 Go 标准库中的一段使用类型嵌入组合方式的代码段：

```go
// $GOROOT/src/sync/pool.go
type poolLocal struct {
    private interface{}   
    shared  []interface{}
    Mutex               
    pad     [128]byte  
}
```

在代码段中，我们在 poolLocal 这个结构体类型中嵌入类型 Mutex，这使得 poolLocal 这个类型具有互斥同步的能力，我们可以通过 poolLocal 类型的变量，直接调用 Mutex 类型的方法 Lock 或 Unlock。

另外，我们在标准库中还会看到类似如下定义接口类型的代码段：

```go
// $GOROOT/src/io/io.go
type ReadWriter interface {
    Reader
    Writer
}
```

这里，标准库通过嵌入接口类型的方式来实现接口行为的聚合，组成大接口，这种方式在标准库中尤为常用，并且已经成为 Go 语言的一种惯用法。

垂直组合本质上是一种 “能力继承”，采用嵌入方式定义的新类型继承嵌入类型的能力。Go 还有一种常见的组合方式，叫水平组合。和垂直组合的能力继承不同，水平组合是一种能力委托（Delegate），我们通常使用接口类型来实现水平组合。

Go 语言中的接口是一个创建设计，它知识方法集合，并且它与实现者之间的关系无需通过显式关键字修饰，它让程序内部各部分之间的耦合降至最低，同时它也是连接程序各个部分之间的 “纽带”。

水平组合的模式有很多，比如一种常见方法就是，通过接受接口类型参数的普通函数进行组合，如以下代码所示：

```go
// $GOROOT/src/io/ioutil/ioutil.go
func ReadAll(r io.Reader)([]byte, error)

// $GOROOT/src/io/io.go
func Copy(dst Writer, src Reader)(written int64, err error)
```

函数 ReadAll 通过 io.Reader 这个接口，将 io.Reader 的实现与 ReadAll 所在的包低耦合地水平组合在一起，从而达到从任意实现 io.Reader 的数据源读取所有数据的目的。类似的水平组合 “模式” 还有点缀器、中间件等。

此外，我们还可以将 Go 语言内置的并发能力进行灵活组合以实现，比如，通过 goroutine + channel 的组合，可以实现类似 Unix Pipe 的能力。

总之，组合原则的应用实质上是塑造 Go 程序的骨架结构。类型嵌入为类型提供了垂直扩展能力，而接口是水平组合的关键，它好比程序肌体上的 “关节”，给予连接 “关节” 的两个部分各自 “自由活动” 的能力，而整体上又实现某种功能。并且，组合也让遵循 “简单” 原则的 Go 语言，在表现力上丝毫不逊色于其他复杂的主流编程语言。

#### 并发

“并发” 这个设计哲学的出现也有有它的背景，CPU 都是靠提高主频来改进性能的，但是这个做法已经遇到瓶颈。主频提高导致 CPU 的功耗和发热量剧增，反过来制约 CPU 性能的进一步提高。2007 年开始，处理器厂商的竞争焦点从主频转向了多核。

在这种大背景下，Go 的设计者在决定创建一门新语言的时候，果断将面向多核、原生支持并发作为新语言的设计原则之一。并且，Go 放弃了传统的基于操作系统线程的并发模型，采用用户层轻量级线程，Go 将之称之为 goroutine。

goroutine 占用的资源非常小，Go 运行时默认为每个 goroutine 分配的占空间仅 2 KB。goroutine 调度的切换也不用陷入（trap）操作系统内核层完成，代价很低。因此，一个 Go 程序中可以创建成千上万个并发的 goroutine。而且，所有的 Go 代码都在 goroutine 中执行，哪怕是 go 运行时的代码也不例外。

在提供了开销较低的 goroutine 的同时，Go 还在语言层面上内置了辅助并发设计的原语：channel 和 select。开发者可以通过语言内置的 channel 传递消息或实现同步，并通过 select 实现多路 channel 的并发控制。相较于传统复杂的线程并发模型，Go 与并发的原生支持将大大降低开发人员在开发并发程序时的心智负担。

此外，并发的设计哲学不仅仅让 Go 在语法层面提供了并发原语支持，对 Go 应用程序设计的影响更为重要。并发是一种程序结构设计的方法，使得并行成为可能。

采用并发方案设计的程序在单核处理器也是可以正常运行的，也许在单核上的处理性能可能不如非并发方案。但随着处理器核数的增多，并发方案可以自然地提高处理性能。

而且，并发与组合的哲学是一脉相承的，并发是一个更大的组合概念，它在程序设计的全局层面对程序进行拆解组合，再映射到程序执行层面上：goroutines 各自执行特定的工作，通过 channel + select 将 goroutines 组合连接起来。并发的存在鼓励程序员在程序设计时进行独立计算的分解，而对并发的原生支持让 Go 语言更适合现代计算环境。

#### 面向工程

Go 语言设计的初衷，就是面向解决真实世界中 Google 内部大规模软件开发中存在的各种问题，为这些问题提供答案，例如：程序构建慢、依赖管理失控、代码难于理解、跨语言构建难等。

Go语言最初设计阶段就将解决工程问题作为 Go 的设计原则之一，去考虑 Go 语法、工具链与标准库的设计，这也是 Go 与其他偏学院派、偏研究型的编程语言在设计思路上的一个重要差异。

语法是编程语言的用户接口，它直接影响开发人员对这门语言的使用体验。在面向工程设计哲学的驱使下，Go 在语法设计细节上做了精心打磨。

* 重新设计编译单元和目标文件格式，实现 Go 源码快速构建，使大工程的构建时间缩短到类似动态语言的交互式解释的编译速度；
* 如果源文件导入它不使用的包，程序将无法编译。这可以充分保证任何 Go 程序的依赖树是精确的，也可以保证构建程序时不会编译额外的代码，从而最大限度地缩短编译时间；
* 去除包的循环依赖，循环依赖会在大规模的代码中引发问题，因为它们要求编译器同时处理更大的源文件集，这会减慢增量构建；
* 包路径是唯一的，包名不必唯一。导入路径必须唯一标识要导入的包，名称只是包的使用者如何引用其内容的约定。“包名称不必是唯一的” 这个约定，可以大大降低开发人员给包起唯一名字的心智负担；
* 不支持默认函数参数。因为在规模工程中，很多开发者利用默认函数参数机制，向函数添加过多的参数以弥补函数 API 的设计缺陷，这会导致函数拥有太多的参数，降低清晰度和可读性；
* 增加类型别名（type alias），支持大规模代码库重构。

在标准库方面，Go 语言标准库功能丰富，多数功能不需要依赖外部的第三方包或库。Go 在标准库中提供了各种高质量且性能优良的功能包，其中 net/http、crypto、encoding 等包充分迎合了云原生时代的关于 API/RPC Web 服务器的构建需求，Go 开发者可以直接基于标准库提供的包实现一个满足生产要求的 API 服务，从而减少对外部第三方包或库的依赖，降低工程代码依赖管理的复杂性，降低开发人员学习第三方库的心理负担。

除此之外，Go 语言还提供了完善的工具链支持，涵盖了编译构建、代码格式化、包依赖管理、静态代码检查、测试、文档生成与查看、性能剖析、语言服务器、运行时程序跟踪等方方面面。

值得重点介绍的是 gofmt，它可以统一 Go 语言的代码风格，使开发者可以更加专注于业务。同时，相同的代码风格可以让开发者的代码阅读、理解和评审工作变得更加容易。Go 的这种统一代码风格思路也开始影响后续新编程语言的设计，并且一些现有的主流编程语言也在借鉴 Go 的一些设计。

在提供丰富工具链的同时，Go 在标准库中还提供了官方的词法分析器、语法解析器和类型检查器相关包，开发者可以基于这些包快速构建并扩展 Go 工具链。

### 总结

这篇文章我们了解了 Go 语言的设计哲学：简单、显式、组合、并发和面向工程。

* 简单是指 Go 语言特性始终保持在少且足够的水平，不走语言特性融合的道路，但又不缺乏生产力。简单是 Go 生产力的源泉，也是 Go 对开发者的最大吸引力；
* 显式是指任何代码行为都需要开发者明确知晓，不存在因隐式转型导致可维护性降低和不安全的结果；
* 组合是构建 Go 程序骨架的主要方式，它可以大幅度降低程序元素间的耦合，提高程序的可扩展性和灵活性；
* 并发是 Go 把握 CPU 向多核方向发展趋势的产物，可以让那个开发人员更容易写出充分利用系统资源、支持性能随 CPU 核数增加而自然提升的应用程序；
* 面向过程是 Go 语言在语言设计上的一个重大创新，它将语言要解决的问题域扩展到那些原本并不是由编程语言去解决的领域，从而覆盖更多开发者在开发过程中的 “痛点”，为开发者提供更好的使用体验。

### 技术拓展

**关于 “类型别名” 的渐进式代码修复（Gradual code repair）**

https://github.com/golang/proposal/blob/master/design/18130-type-alias.md

它也是 Go 面向工程设计哲学的体现，另外 type alias 对基于现有实现进行扩展并做出新的封装方面也有 “奇效”。

## 环境配置

这一篇文章主要介绍如何安装和配置 Go 语言开发环境。

### 选择 Go 版本

挑选版本之前，我们先来看看 Go 语言的版本发布策略。

Go 团队目前已经将版本发布节奏稳定在每年发布两次大版本，通常是二月份和八月份。Go 团队承诺对最新的两个 Go 稳定大版本提供支持，比如目前的最新的大版本是 Go 1.19，那么 Go 团队就会为 Go 1.19 和 Go 1.18 版本提供支持。如果 Go 1.20 版本发布，那支持的版本将编程 Go 1.20 和 Go 1.19。支持的范围主要包括修复版本中存在的重要问题、文档变更以及安全问题更新等。

基于这样的版本发布策略，我们在选择版本时可以参考这几种思路：

一般情况下，建议使用最新版本。因为 Go 团队发布的 Go 语言稳定版本的平均质量一直是很高的，很少有影响使用的重大 bug。我们也不必担心新版本的支持问题，Google 的自有产品，比如 Google App Engine 支持都会很快，一般在 Go 新版本发布不久后，GAE 便会支持最新版本的 Go。

你还可以根据不同实际项目需要或开源社区的情况使用不同版本。

有的开源项目采纳 Go 团队建议，在 Go 最新版本发布不久就将当前项目的 Go 编译器升级到最新版，例如 kubernets 项目；有的开源项目，例如 docker 则比较谨慎，这些项目可能会使用两个发布周期之前的版本。多数项目处于两者之间，也就是使用次新版，即最新版本之前的那个版本。

因为我们是 Go 语言学习，所以推荐直接使用 Go 最新发布版。这样我们可以体验到 Go 的最新语言特性，应用到标准库的最新 API 以及 Go 工具链的最新功能。

选定 Go 版本后，接下来我们就来看看几种常见的 Go 安装方法。

### 安装 Go

在 Mac 上我们可以在图形界面的引导下进行 Go 的[安装](https://go.dev/dl/)。

首先我们需要下载适用于 Mac 的 Go 安装包（这里以 arm 为例）：

```
wget -c https://go.dev/dl/go1.19.4.darwin-arm64.pkg
```

安装包下载完毕后，双击安装包，就可以打开标准的 Mac 软件安装界面，如下图所示：

<img src="./images/install.png" />

按照软件安装向导提示，一路点击 “继续”，我们便可以完成 Go 在 Mac 上的安装。

Mac 上的 Go 安装包默认也会将 Go 安装到 /usr/local/go 路径下面。因此，如果要在任意路径下使用 Go，我们也需将这个路径加入到用户的环境变量 PATH  中。

```
export PATH=$PATH:/usr/local/go/bin
```

最后，我们同样可以通过 go version 命令验证这次安装是否成功。除此之外，我们还可以使用 brew 安装 Go。

### 配置 Go

Go 在安装后是开箱即用的，这也意味着我们在使用 Go 之前无需做任何配置。但为了更好地了解和学习 Go，我们还是要认识一些 Go 自带的常用配置项。Go 的配置项是以环境变量的形式存在的，我们可以通过下面这个命令查看 Go 的这些配置项：

```
go env
```

下面总结了一些常用配置项：

| 名称        | 作用                                                         | 值                                                           |
| ----------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| GOARCH      | 用于指示 Go 编译器生成代码所针对的平台 CPU 架构              | 主要值是 AMD64、Arm 等，默认值是本机的 CPU 架构              |
| GOOS        | 用于指示 Go 编译器生成代码所针对的操作系统                   | 主要值是 Linux、Darwin、Windows 等，默认值是本机的操作系统   |
| GO111MODULE | 它的值决定当前使用的构建模式是传统的 GOPATH 模式还是新引入的 GO Module 模式 | 在 Go 1.16 版本 Go Module 构建模式默认开启，该变量值默认为 on，测试 Go 1.19 版本默认为 “” |
| GOCACHE     | 用于指示存储构建结果缓存的路径，这些缓存可能会被后续的构建所使用 | 在不同的操作系统中，GOCACHE 有不同的默认值。以 Mac 为例，我们使用 go env GOCACHE 查看其值为：$HOME/Library/Caches/go-build |
| GOMODCACHE  | 用于指示存放 Go Module 的路径                                | 在不同的操作系统上，GOMODCACHE 有不同的默认值。以 Mac 为例，我们使用 go env GOOMODCACHE 查看其值为：$HOME/go/pkg/mod |
| GOPROXY     | 用来配置 Go Module proxy 服务                                | 默认值为 “https://proxy.golang.org,direct”。中国大陆地区，可以设置为大陆地区提供的 module proxy 服务以加速 Go Module 的获取速度，值为 “https://goproxy.cn,direct”。 |
| GOPATH      | 在传统的 GOPATH 构建模式下，用于指示 Go 包搜索路径的环境变量，在 Go module 机制启用之前是 Go 核心配置项。Go 1.8 版本之前需要手动配置，Go 1.8 版本引入了默认的 GOPATH（$HOME/go）。在 Go Module 模式正式上位后，很可能会被移除。 |                                                              |
| GOROOT      | 指示 Go 安装路径。Go 1.10 版本引入默认 GOROOT，开发者无需显式设置，Go 程序会自动根据自己所在路径推导出 GOROOT 的路径。 |                                                              |

如果你还想了解更多关于 Go 配置项的说明，可以通过 go help environment 命令查看。

### 总结

在这篇文章中，我们讲解三种 Go 版本的选择策略：

* 第一种，也是比较推荐的一种，那就是使用 Go 最新版本，这样就可以体验到 Go 的最新语言特性，应用到标准库的最新 API 以及 Go 工具链的最新功能，并且很多老版本中的 bug 在最新版本中都会得到及时修复；
* 如果你对最新版本的稳定性存在顾虑，你也可以选择使用此新版；
* 最后，如果你要考虑现存生产项目或开源项目，只需要于选择项目保持一致就可以。

确认完 Go 版本后，我们介绍了如果安装 Go。最后，我们讲解了 Go 的一些常用配置项。

有了 Go 开发环境，接下来我们就开始学习如何编写 Go 代码。

## Go 程序结构

正式开始之前，首先说明一下，这节课对于开发 Go 程序所使用的编辑器工具没有任何要求。

如果你喜欢使用某个集成开发环境（Integrated Development Environment，IDE），那么就用你喜欢的 IDE 就好。

在这里只推荐两款好用的 IDE，GoLand 或 Visual Studio Code（简称 VS Code）。GoLand 是知名 IDE 出品公司 JetBrains 准对 Go 语言推出的 IDE 产品，也是目前市面上最好用的 Go IDE；VS Code 则是微软开源的跨语言源码编辑器，通过集成语言插件（Go 开发者可以使用 Go 官网维护的 vscode-go 插件），可以让它变成类 IDE 的工具。

如果你有黑客情怀，喜欢优雅高效地使用命令行，那么像 Vim、Emacs 这样的基于终端的编辑器同样可以用于编写 Go 源码。以 Vim 为例，结合 vim-go、coc.nvim（代码补全）以及 Go 官方维护的 gopls 语言服务器，在编写 Go 代码时也可以体会到 “飞一般” 的感觉。

### “hello world” 示例程序

新建一个 helloworld 文件夹。

```
mkdir helloworld
cd helloworld
```

首先，我们需要创建一个名为 main.go 的源文件。

这里说下 Go 的命名规则。Go 源文件总是以全小写字母形式的短小单词命名，并且以 .go 扩展名结尾。

现在，我们打开刚才创建的 main.go 文件，编写下面这段代码：

```go
package main

import "fmt"

func main() {
	fmt.Println("hello, world")
}
```

编写完成后，我们就可以通过以下命令编译和运行这个文件。

```
go build main.go
./main
```

到这里你应该可以看到终端输出 “hello, world” 字符串。

现在，让我们来分析下这段代码。首先值得注意的部分是这个：

```go
package main
```

这一行代码定义了 Go 中的一个包 package。包是 Go 语言的基本组成单元，通常使用单个的小写单词命名，一个 Go 程序本质上就是一组包的集合。所有 Go 代码都有自己隶属的包，这里我们的 “hello, world” 示例的所有代码都在一个名为 main 的包中。main 包在 Go 中是一个特殊的包，整个 Go 程序中仅允许存储一个名为 main 的包。

main 包中的主要代码是一个名为 main 的函数：

```go
func main() {
	fmt.Println("hello, world")
}
```

这里的 main 函数也比较特殊：当你运行一个可执行的 Go 程序的时候，所有的带啊吗都会从这个入口函数开始运行。这段代码的第一行声明了一个名为 main 的、没有任何参数和返回值的函数。如果你想给函数声明参数，必须放到括号中。

另外，花括号 {} 用来标记函数体，Go 要求所有的函数体都要被花括号包裹起来。我们推荐把左花括号与函数声明置于同一行并以空格分割。Go 语言内置了一套 Go 社区约定俗成的代码风格，并随安装包提供了一个名为 Gofmt 的工具，这个工具可以帮助你将代码自动格式化为约定的风格。

Gofmt 是 Go 语言在解决规模化（scale）问题上的一个最佳实践，并成了 Go 语言吸引其他语法开发者的一大卖点。很多其他主流语言也在效仿 Go 语言推出自己的 format 工具，例如：Java formatter、Clang formatter、Dartfmt 等。因此，作为 Go 开发人员，在提交你的代码前要使用 Gpfmt 格式化你的 Go 源码。

我们再来看一看 main 函数体中的代码：

```go
fmt.Println("hello, world")
```

这一行代码已经完成整个示例程序的所有工作：将字符串输出到终端的标准输出（stdout）上。这里有几个细节需要注意：

**标准 Go 代码风格使用 Tab 而不是空格使用缩进，代码风格格式化工作也可以交由 gofmt 完成。**

**我们调用一个名为 Println 的函数，这个函数位于 Go 标准库的 fmt 包中。输出 “hello, world” 做了两部操作。**

第一步是在源文件的开始处通过 import 声明导入 fmt 包的包路径。

```go
import "fmt"
```

第二步则是在 main 函数体内，通过 fmt 这个操作符（Qualified Identifier）调用 PrintIn 函数。虽然两处都使用了 “fmt” 这个字面值，但在这两处 “fmt” 字面值所代表的含义是一样的。

* import “fmt” 一行中的 “fmt” 代表的是包的导入路径（Import），它代表的是标准库下的 fmt 目录，整个 import 声明语句的含义就是导入标准库 fmt 目录下的包；
* fmt.PrintIn 函数调用一行中给的 “fmt” 代表的则是包名。

通常导入路径的最后一个分段名与包名是相同的，这也很容易让人误解 import 声明语句中的 “fmt” 指的是包名。

main 函数体中之所以可以调用 fmt 包中的 PrintIn 函数，还有最后一个原因，那就是 PrintIn 函数的首字母是大写的。在 Go 语言中，只有首字母为大写的标识符才是导出的（Exported），才能对包外的代码可见；如果首字母是小写的，那么就说明这个标识符仅限于在声明它的包内可见。

另外，在 Go 语言中，main 包是不可以像标准库 fmt 包那样导入的，如果导入 main 包，在代码编译阶段就会收到 Go 编译器错误：import "xx/main" is a program, not an importable package。

最后，在整个示例程序源码中，我们都没有使用分号来表示语句结束。不过，其实 Go 语言的正式语法规范是使用分号 “;” 来做结尾标识符的。因为大多数分号都是可选的，常常被省略，不过在源码编译时，Go 编译器会自动插入这些被省略的分号。

### 程序如何编译

